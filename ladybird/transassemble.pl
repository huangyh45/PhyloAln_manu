#!/usr/bin/env perl

use Getopt::Long;
use Parallel::ForkManager;
use strict;

my $trinitydir='/public/lihaosen/anaconda3/envs/transtools/bin';
my $soaptransdir='/public/lihaosen/anaconda3/envs/transtools/bin';
my $redundansdir='/public/lihaosen/software/redundans';
my $smallfasta='/public/lihaosen/software/script/t.fas';
my $oasesdir='/public/lihaosen/anaconda3/envs/transtools/bin';
my $velvetdir='/public/lihaosen/anaconda3/envs/transtools/bin';
my $transabyssdir='/public/lihaosen/anaconda3/envs/transabyss/bin';
my $idbatrandir='/public/lihaosen/anaconda3/envs/transtools/bin';
my $crocodir='/public/lihaosen/software/CroCo-master';
my $scriptdir='/public/lihaosen/software';
my $blastprog='/public/lihaosen/software/ncbi-blast-2.8.1+/bin/blastn';
my $ingroupdatabase='/public/lihaosen/software/Coccinelloidea.fasta';
my $outgroupdatabase='/public/lihs/annotation/nt/nt';
my $acc2tax='/public/lihaosen/software/Coccinelloidea.fasta.list';
my $fastqdumpdir='/public/lihaosen/software/sratoolkit.3.0.2-centos_linux64/bin';
my $evidentialgenedir='/public/lihaosen/software/EvidentialGene';
my $bowtie2dir='/public/lihaosen/anaconda3/bin';
my $hisat2dir='';
my $samtoolsdir='/public/lihaosen/anaconda3/bin';
my $trimmomatic='/public/lihaosen/software/Trimmomatic-0.39/trimmomatic-0.39.jar';
my $adapterdir='/public/lihaosen/software/Trimmomatic-0.39/adapters';

Getopt::Long::Configure ("no_ignore_case");
our ($workdir,$parallel,$trim,$trimpara,$genome,$bam,$trinity,$unigene,$soap,$soapF,$oases,$abyss,$idba,$bowtie2,$removecontam,$explist,$minexp,$evigene,$noclean,$exist,$help);
our $cpu=8;
my $minkmer=21;
my $maxkmer=61;
my $kmerstep=10;
my $croco=0;
our $crocofasta=2;
GetOptions("workingdir|d=s" => \$workdir,
           "cpus|n=i" => \$cpu,
	   "parallel|p=i" => \$parallel,
           "minkmer|k=i" => \$minkmer,
           "maxkmer|K=i" => \$maxkmer,
           "kmerstep|s=i" => \$kmerstep,
	   "Trimmomatic|M" => \$trim,
	   "Trimmomatic_parameter=s" => \$trimpara,
	   "genome|g" => \$genome,
	   "bam|b" => \$bam,
           "Trinity|T" => \$trinity,
	   "Trinity_unigene" => \$unigene,
	   "SOAPdenovoTrans|S" => \$soap,
	   "SOAP_fill_gaps|SF" => \$soapF,
	   "Oases|O" => \$oases,
	   "TransABySS|A" => \$abyss,
	   "IDBATran|I" => \$idba,
	   "Bowtie2|B" => \$bowtie2,
	   "CroCo|C=i" => \$croco,
	   "CroCo_fasta=i" => \$crocofasta,
           "removecontam|R=s" => \$removecontam,
	   "expression_list=s" => \$explist,
	   "min_expression=f" => \$minexp,
	   "EvidentialGene|E" => \$evigene,
	   "blastprog=s" => \$blastprog,
	   "ingroupdatabase=s" => \$ingroupdatabase,
	   "outgroupdatabase=s" => \$outgroupdatabase,
	   "acc2tax=s" => \$acc2tax,
	   "no_clean" => \$noclean,
           "use_existing" => \$exist,
           "help|h" => \$help
        );
if($help) {
printf "
perl $0
A pipeline to assemble the transcriptomes, clean the contamination, and conduct redundancy reduction, gene reconstruction and other related analysis.

Usage:
-workingdir|-d	the working directory, which must contain transcriptomic FASTQs, 
		accepting SRA files(.sra), paired files(_1.fq/fastq(.gz), _2.fq/fastq
		(.gz) or .L.fastq, .R.fastq) and unpaired files(.fq/fastq(.gz)). And all
		 the result will be generated in this directory
		(default=the current working directory)
-cpus|-n        the maximum number of CPUs that can be used(default=8)
		Noticed: the CPUs divided by '-parallel' are most efficient
-parallel|-p	the number of parallel tasks of assembling at the same time
		(default=the number of transcriptomes to be assembled, but this number
		always causes too large memory)
-minkmer|-k	the minimum kmer(default=21)
-maxkmer|-K     the maximum kmer(default=61)
-kmerstep|-s	the step of kmer(default=10)
-Trimmomatic|-M		use Trimmomatic to trim the reads
-Trimmomatic_parameter	the parameters to be used in Trimmomatic
			(default='ILLUMINACLIP:$adapterdir/TruSeq3-P(S)E.fa:2:30:10 SLIDINGWINDOW:4:5 LEADING:5 TRAILING:5 MINLEN:25')
-genome|-g	use the genomes(xxxname.genome.fasta) as the references to guide the 
		assemblies. If this parameter is set, the FASTQs will be mapped to the 
		genomes by HISAT2
-bam|-b		use the bam files mapped to the genomes(bam/xxxname.bam) to guide the 
		assemblies
		(default=generated by HISAT2 when '-genome' is set)
-Trinity|-T	use Trinity to assemble the transcriptomes
-Trinity_unigene	generate the unigene dataset from the Trinity assembly
-SOAPdenovoTrans|-S	use SOAPdenovo-Trans to assemble the transcriptomes
-SOAP_fill_gaps|-SF	fill gaps in scaffolds when assembling by SOAPdenovo-Trans
			(recommended) 
-Oases|-O	use Oases to assemble the transcriptomes
-TransABySS|-A	use Trans-ABySS to assemble the transcriptomes
-IDBATran|-I	use IDBA-Tran to assemble the transcriptomes. It cannot be genome-guided
-Bowtie2|-B	use Bowtie2 to assess the read content of the transcriptome assemblies
-CroCo|-C	use CroCo to remove the cross contamination among the same batch(1 means running
                CroCo with all assemblies, 2 means running CroCo after each kind of assembly to
                avoid using too much memory, default=not run CroCo)
-CroCo_fasta	the level to control the fasta output after CroCo(default=2, 1 means no
		fasta output and only to detect the cross contamination, 2 means to 
		output the 'clean' fasta, 3 means to output all the 5 kinds of fasta 
		files)
-removecontam|-R	use the command of the script removecontam.pl to remove the outgroup 
			contamination('1' means the fast mode command '-p 98 -k 80 -f 30 -g 10 
			-z 3', '2' means the ultra fast mode command '-p 98 -q 10 -z 9', but less
			 accurate, other command can be provided all in quotation marks except 
			for '-i', '-o', '-a', '-b', '-c', '-u', '-v', '-w', '-t', '-x', '-m' and 
			'-n', default=not remove)
-expression_list        the seqid-to-expression list or CroCo quants file, if it is provided, you 
			can remove sequences based on their expression values by removecontam.pl
                        (default=CroCo quant file, '1' means not remove based on expression)
-min_expression         the minimum expression value to remain the sequences(default=remove the 
			sequences with no expression/expression=0)
-EvidentialGene|-E	use the script tr2aacds.pl in EvidentialGene pipeline to conduct
			redundancy reduction and gene reconstruction
-blastprog	the blast program used when removing the outgroup contamination
		(default='$blastprog')
-ingroupdatabase	the ingroup database used when removing the outgroup 
			contamination(default='$ingroupdatabase')
-outgroupdatabase	the outgroup database used when removing the outgroup 
			contamination(default='$outgroupdatabase')
-acc2tax	the tsv file with format as 'ingroup_db_seq_id species' in each line 
		used to identify the species when removing the outgroup contamination
		(default='$acc2tax')
-no_clean	not clean the intermediate files, not recommended because the files will
		always occupy large space
-use_existing   use the files generated in last run unless you manually set, the working
                directory must be the same
-help|-h        print this message

Example:
To assemble 8 transcriptomes by Trinity and remove the cross contamination: 
$0 -n 32 -T -C 1

To assemble 9 transcriptomes by all the 5 softwares with unigene in Trinity and gap filling in SOAPdenovo-Trans, remove the cross contamination and outgroup contamination, and conduct redundancy reduction and gene reconstruction, using the same existing file:
$0 -n 36 -T -Trinity_unigene -S -SOAP_fill_gaps -O -A -I -C 1 -R 1 -E -use_existing

";
exit 0;
}

if($workdir) {
	chdir("$workdir") or die "\nError: fail to enter directory '$workdir'!\n";
}
our $path=$ENV{'PATH'};
unless(-d "log") {mkdir("log") or die "\nError: fail to create the directory 'log'!\n";}
chomp($workdir=`pwd`);
our $logdir="$workdir/log";

printf "Checking and preparing the FASTQs...\n";
my %fq;
while(<*>) {
        my $file=$_;
	if($file=~/\.sra$/) {
		$file=~s/\.sra$//;
		if($fq{$file}) {die "\nError: repeat '$file' SRAs or FASTQs!\n";}
		printf "Converting $file.sra to fastq...\n";
		runcmd("fastq-dump --defline-seq '@\$sn[_\$rn]/\$ri' --split-files $file.sra 2>&1",'prepare',$fastqdumpdir);
		if(-s "$file\_2.fastq") {
			fastqcorrect($file);
			$fq{$file}='p';
		}
		elsif(-s "$file\_1.fastq") {
			runcmd("mv $file\_1.fastq $file.fastq",'prepare');
			$fq{$file}='s';
		}
	}
        elsif($file=~/\.(f(ast)?q(\.gz)?)$/) {
		my $suffix=$1;
                my $suffixq=quotemeta $suffix;
                if($file=~s/\.L\.fastq$//) {
			if($fq{$file}) {die "\nError: repeat '$file' SRAs or FASTQs!\n";}
			if(-e "$file.R.fastq") {$fq{$file}='p';}
			else {die "\nError: fail to find the paired file '$file.R.fastq' of '$file.L.fastq'!\n";}
		}
		elsif($file=~s/\.R\.fastq$//)  {
                        unless(-e "$file.L.fastq") {die "\nError: fail to find the paired file '$file.L.fastq' of '$file.R.fastq'!\n";}
                }
		elsif($file=~s/\_1\.$suffixq$//)  {
			if($fq{$file}) {die "\nError: repeat '$file' SRAs or FASTQs!\n";}
                        if(-e "$file\_2.$suffix") {
				if($suffix=~/\.gz$/) {
					printf "Unzipping $file...\n";
					runcmd("gzip -dc $file\_1.$suffix > $file.L.fastq",'prepare');
                                        runcmd("gzip -dc $file\_2.$suffix > $file.R.fastq",'prepare');
				}
				else {
					printf "Renaming $file...\n";
					runcmd("cp $file\_1.$suffix $file.L.fastq",'prepare');
					runcmd("cp $file\_2.$suffix $file.R.fastq",'prepare');
				}
				$fq{$file}='p';
			}
                        else {die "\nError: fail to find the paired file '$file\_2.$suffix' of '$file\_1.$suffix'!\n";}
                }
                elsif($file=~s/\_2\.$suffixq$//)  {
                        unless(-e "$file\_1.$suffix") {die "\nError: fail to find the paired file '$file\_1.$suffix' of '$file\_2.$suffix'!\n";}
                }
                else {
			$file=~s/\.$suffixq$//;
			if($fq{$file}) {die "\nError: repeat '$file' SRAs or FASTQs!\n";}
			if($suffix=~/\.gz$/) {
				printf "Unzipping $file...\n";
				runcmd("gzip -dc $file.$suffix > $file.fastq",'prepare');
				unless($noclean) {runcmd("rm $file.$suffix",'prepare');}
                        }
                        elsif($suffix ne 'fastq') {
				printf "Renaming $file...\n";
                                runcmd("mv $file.$suffix $file.fastq",'prepare');
                        }
			$fq{$file}='s';
		}
        }
}
if((keys %fq)==0) {die "\nError: fail to find any transcriptomic FASTQ files in the working directory!\n";}
printf "\nTranscriptomic FASTQs:\n";
foreach my $fqname (keys %fq) {
	if($fq{$fqname} eq 'p') {
		printf "$fqname.L.fastq\t$fqname.R.fastq\n";
		if(-e "$fqname\_1.fastq.gz"&&-e "$fqname\_2.fastq.gz"||-e "$fqname\_1.fq.gz"&&-e "$fqname\_2.fq.gz") {
			unless($noclean) {runcmd("rm $fqname\_*.f*q.gz",'prepare');}
		}
		elsif(-e "$fqname\_1.fastq"&&-e "$fqname\_2.fastq"||-e "$fqname\_1.fq"&&-e "$fqname\_2.fq") {
			runcmd("rm $fqname\_*.f*q",'prepare');
		}
	}
	elsif($fq{$fqname} eq 's') {printf "$fqname.fastq\n";}
	unless(-d "assemble_$fqname") {mkdir("assemble_$fqname") or die "\nError: fail to create the directory 'assemble_$fqname'!\n";}
}
unless($parallel) {$parallel=(keys %fq);}
if($croco) {
	unless(-d "CroCo") {mkdir("CroCo") or die "\nError: fail to create the directory 'CroCo'!\n";}
}
if($bowtie2) {
        unless(-d "Bowtie2") {mkdir("Bowtie2") or die "\nError: fail to create the directory 'Bowtie2'!\n";}
}

if($trim) {
	printf "Trimming the reads...\n";
        unless(-d "trim") {mkdir("trim") or die "\nError: fail to create the directory 'trim'!\n";}
	unless($trimpara) {
		$trimpara="ILLUMINACLIP:$adapterdir/TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:4:5 LEADING:5 TRAILING:5 MINLEN:25";
	}
	foreach my $name (keys %fq) {
                if($exist&& -e "trim/$name.ok") {next;}
		if($fq{$name} eq 'p') {
                        runcmd("mv $name.L.fastq trim/$name.raw.L.fq; mv $name.R.fastq trim/$name.raw.R.fq; java -jar $trimmomatic PE -threads $cpu -phred33 trim/$name.raw.L.fq trim/$name.raw.R.fq $name.L.fastq trim/$name.L.unpaired.fq.gz $name.R.fastq trim/$name.R.unpaired.fq.gz $trimpara 2>&1","Trimmomatic_$name");
                	unless($noclean) {runcmd("gzip trim/$name.raw.L.fq; gzip trim/$name.raw.R.fq","Trimmomatic_$name");}
		}
                elsif($fq{$name} eq 's') {
			my $command="mv $name.fastq trim/$name.raw.fq; java -jar $trimmomatic SE -threads $cpu -phred33 trim/$name.raw.fq $name.fastq $trimpara 2>&1";
			$command=~s/TruSeq3-PE\.fa/TruSeq3-SE.fa/;
                        runcmd("$command","Trimmomatic_$name");
			unless($noclean) {runcmd("gzip trim/$name.raw.fq","Trimmomatic_$name");}
                }
		open(OK,">trim/$name.ok") or die "\nError: fail to open 'trim/$name.ok'!\n";
        	close(OK);
	}
}

if($genome&&(!$bam)) {
	printf "Mapping the FASTQs to the genome...\n";
	unless(-d "HISAT2") {mkdir("HISAT2") or die "\nError: fail to create the directory 'HISAT2'!\n";}
	unless(-d "bam") {mkdir("bam") or die "\nError: fail to create the directory 'bam'!\n";}
	foreach my $name (keys %fq) {
		if($exist&& -s "bam/$name.bam") {next;}
		unless($exist&& -s "HISAT2/$name.sam") {
			runcmd("hisat2-build $name.genome.fasta HISAT2/$name 2>&1","HISAT2_$name",$hisat2dir);
			if($fq{$name} eq 'p') {
				runcmd("hisat2 -x HISAT2/$name -S HISAT2/$name.sam -p $cpu -1 $name.L.fastq -2 $name.R.fastq 2>&1","HISAT2_$name",$hisat2dir);
			}
			elsif($fq{$name} eq 's') {
				runcmd("hisat2 -x HISAT2/$name -S HISAT2/$name.sam -p $cpu -U $name.fastq 2>&1","HISAT2_$name",$hisat2dir);
                	}
		}
		runcmd("samtools view -@ $cpu -bS HISAT2/$name.sam > HISAT2/$name.bam","HISAT2_$name",$samtoolsdir);
        	runcmd("samtools sort -@ $cpu -o bam/$name.bam HISAT2/$name.bam 2>&1","HISAT2_$name",$samtoolsdir);
        	unless($noclean) {runcmd("rm HISAT2/$name.*","HISAT2_$name");}
	}
	$bam=1;
}

my $assemsw=0;
if($trinity) {
	printf "Assembling by Trinity...\n";
	unless($exist) {
		my %cm;
		foreach my $name (keys %fq) {
			if($bam) {$cm{"Trinity --genome_guided_bam bam/$name.bam --genome_guided_max_intron 10000 --output trinity_dir_$name --CPU xxxcpu --max_memory 100G; mv trinity_dir_$name/Trinity-GG.fasta trinity_dir_$name/Trinity.fasta 2>&1"}="Trinity_$name";}
                	elsif($fq{$name} eq 'p') {$cm{"Trinity --seqType fq --left $name.L.fastq --right $name.R.fastq --output trinity_dir_$name --CPU xxxcpu --max_memory 100G 2>&1"}="Trinity_$name";}
                	elsif($fq{$name} eq 's') {$cm{"Trinity --seqType fq --single $name.fastq --output trinity_dir_$name --CPU xxxcpu --max_memory 100G 2>&1"}="Trinity_$name";}
		}
		runcmdpm(\%cm,$trinitydir);
	}
	foreach my $name (keys %fq) {
		if($exist&& -s "assemble_$name/trinity_dir_$name/Trinity.fasta") {
			if($unigene&&(!(-s "assemble_$name/trinity_dir_$name/unigene.fasta"))) {
				runcmd("util/misc/get_longest_isoform_seq_per_trinity_gene.pl assemble_$name/trinity_dir_$name/Trinity.fasta > assemble_$name/trinity_dir_$name/unigene.fasta","Trinity_$name",$trinitydir);
			}
			next;
		}
		my $commandps;
		if($bam) {$commandps="Trinity --genome_guided_bam bam/$name.bam --genome_guided_max_intron 10000 --output trinity_dir_$name --CPU $cpu --max_memory 100G; mv trinity_dir_$name/Trinity-GG.fasta trinity_dir_$name/Trinity.fasta 2>&1";}
		elsif($fq{$name} eq 'p') {$commandps="Trinity --seqType fq --left $name.L.fastq --right $name.R.fastq --output trinity_dir_$name --CPU $cpu --max_memory 100G 2>&1";}
        	elsif($fq{$name} eq 's') {$commandps="Trinity --seqType fq --single $name.fastq --output trinity_dir_$name --CPU $cpu --max_memory 100G 2>&1";}
		runcmdrp($commandps,"trinity_dir_$name/Trinity.fasta","trinity_dir_$name","Trinity_$name",$trinitydir);
		if($noclean) {
			runcmd("mv trinity_dir_$name assemble_$name/trinity_dir_$name","Trinity_$name");
		}
		else {
			mvdl("trinity_dir_$name","assemble_$name/trinity_dir_$name","Trinity_$name","Trinity.fasta");
		}
		if($unigene) {
			runcmd("util/misc/get_longest_isoform_seq_per_trinity_gene.pl assemble_$name/trinity_dir_$name/Trinity.fasta > assemble_$name/trinity_dir_$name/unigene.fasta","Trinity_$name",$trinitydir);
		}
	}
	if($bowtie2) {
                runBowtie2(\%fq,'Trinity',$bowtie2dir,"assemble_xxxname/trinity_dir_xxxname/Trinity.fasta");
        }
	if($croco==2&&(keys %fq)>1) {
		runCroCo(\%fq,'Trinity',$crocodir,"assemble_xxxname/trinity_dir_xxxname/Trinity.fasta");
	}
	$assemsw+=1;
}

if($soap) {
        printf "Assembling by SOAPdenovo-Trans...\n";
	foreach my $name (keys %fq) {
		if($exist&& -s "assemble_$name/$name\_soap.conf") {next;}
		elsif($exist&& -s "$name\_soap.conf") {next;}
		elsif($fq{$name} eq 'p') {
			runcmd("redundans.py -f $smallfasta -o $name\_out -t $cpu -v -i $name.L.fastq $name.R.fastq --noreduction --noscaffolding --nocleaning 2>&1","Soap_$name",$redundansdir);
		}
		elsif($fq{$name} eq 's') {
			runcmd("redundans.py -f $smallfasta -o $name\_out -t $cpu -v -i $name.fastq --noreduction --noscaffolding --nocleaning 2>&1","Soap_$name",$redundansdir);
		}
		reconf("$name\_out/_gapcloser.1.conf","$workdir/$name\_soap.conf");
		runcmd("rm -rf $name\_out $name.R.fastq.is.txt","Soap_$name");
	}
	unless($exist) {
		my (%cm,$soapprog);
		foreach my $name (keys %fq) {
                	for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
                        	if($k>31) {$soapprog='SOAPdenovo-Trans-127mer';}
                        	else {$soapprog='SOAPdenovo-Trans-31mer';}
				if($soapF) {$cm{"mkdir $name\_soap_k$k; cd $name\_soap_k$k; $soapprog all -s $workdir/$name\_soap.conf -K $k -p xxxcpu -o transcripts -F 2>&1"}="Soap_$name\_k$k";}
				else {$cm{"mkdir $name\_soap_k$k; cd $name\_soap_k$k; $soapprog all -s $workdir/$name\_soap.conf -K $k -p xxxcpu -o transcripts 2>&1"}="Soap_$name\_k$k";}
			}
		}       
                runcmdpm(\%cm,$soaptransdir);
        }
	foreach my $name (keys %fq) {
                for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
			if($exist&& -s "assemble_$name/$name\_soap_k$k/soap.fasta") {next;}
                	my $prog;
			if($k>31) {$prog='SOAPdenovo-Trans-127mer';}
                        else {$prog='SOAPdenovo-Trans-31mer';}
			if($soapF) {runcmdrp("mkdir $name\_soap_k$k; cd $name\_soap_k$k; $prog all -s $workdir/$name\_soap.conf -K $k -p $cpu -o transcripts -F 2>&1","$name\_soap_k$k/transcripts.scafSeq","$name\_soap_k$k","Soap_$name\_k$k",$soaptransdir);}
			else {runcmdrp("mkdir $name\_soap_k$k; cd $name\_soap_k$k; $prog all -s $workdir/$name\_soap.conf -K $k -p $cpu -o transcripts 2>&1","$name\_soap_k$k/transcripts.scafSeq","$name\_soap_k$k","Soap_$name\_k$k",$soaptransdir);}
			renameseq("$name\_soap_k$k/transcripts.scafSeq","$name\_soap_k$k/soap.fasta");
                	if($noclean) {
                        	runcmd("mv $name\_soap_k$k assemble_$name/$name\_soap_k$k","Soap_$name\_k$k");
                	}
                	else {
                        	mvdl("$name\_soap_k$k","assemble_$name/$name\_soap_k$k","Soap_$name\_k$k","soap.fasta","transcripts.contig");
                	}
		}
		unless($exist&& -s "assemble_$name/$name\_soap.conf") {
			runcmd("mv $name\_soap.conf assemble_$name/$name\_soap.conf","Soap_$name");
		}
        }
	my @fas;
        for(my $k=$maxkmer;$k>=$minkmer;$k=$k-$kmerstep) {
        	push(@fas,"assemble_xxxname/xxxname_soap_k$k/soap.fasta")
        }
	if($bowtie2) {
		runBowtie2(\%fq,'Soap',$bowtie2dir,@fas);
	}
	if($croco==2&&(keys %fq)>1) {
		runCroCo(\%fq,'Soap',$crocodir,@fas);
        }
        $assemsw+=1;
}

if($oases) {
	printf "Assembling by Oases...\n";
	unless($exist) {
		my $Mk=$maxkmer+2;
                my %cm;
                foreach my $name (keys %fq) {
                        if($bam) {
                                $cm{"export OMP_THREAD_LIMIT=xxxcpu; velveth $name $minkmer,$Mk,$kmerstep -reference -bam bam/$name.bam 2>&1"}="Oases_$name";
                        }
                        elsif($fq{$name} eq 'p') {
                                $cm{"export OMP_THREAD_LIMIT=xxxcpu; velveth $name $minkmer,$Mk,$kmerstep -shortPaired -fastq -separate $name.L.fastq $name.R.fastq 2>&1"}="Oases_$name";
                        }
                        elsif($fq{$name} eq 's') {
				$cm{"export OMP_THREAD_LIMIT=xxxcpu; velveth $name $minkmer,$Mk,$kmerstep -short -fastq $name.fastq 2>&1"}="Oases_$name";
                        }
                }
                runcmdpm(\%cm,$velvetdir);
                %cm=();
		foreach my $name (keys %fq) {
                        for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
				$cm{"export OMP_THREAD_LIMIT=xxxcpu; velvetg $name\_$k -read_trkg yes 2>&1; oases $name\_$k 2>&1"}="Oases_$name\_k$k";
			}
                }
		runcmdpm(\%cm,"$velvetdir:$oasesdir");
	}
	$ENV{'OMP_THREAD_LIMIT'}=$cpu;
	foreach my $name (keys %fq) {
                for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
                        if($exist&& -s "assemble_$name/$name\_oases_k$k/oases.fasta") {next;}
			my $oasescommand=" 2>&1; velvetg $name\_$k -read_trkg yes 2>&1; oases $name\_$k 2>&1";
			if($bam) {
                                $oasescommand="velveth $name\_$k $k -reference -bam bam/xxxname.bam".$oasescommand;
                        }
			elsif($fq{$name} eq 'p') {
				$oasescommand="velveth $name\_$k $k -shortPaired -fastq -separate $name.L.fastq $name.R.fastq".$oasescommand;
			}
			elsif($fq{$name} eq 's') {
                                $oasescommand="velveth $name\_$k $k -short -fastq -separate $name.fastq".$oasescommand;
			}
                        runcmdrp($oasescommand,"$name\_$k/transcripts.fa","$name\_$k","Oases_$name\_k$k","$velvetdir:$oasesdir");
			runcmd("mv $name\_$k $name\_oases_k$k","Oases_$name\_k$k");
                        renameseq("$name\_oases_k$k/transcripts.fa","$name\_oases_k$k/oases.fasta");
                        if($noclean) {
                                runcmd("mv $name\_oases_k$k assemble_$name/$name\_oases_k$k","Oases_$name\_k$k");
                        }
                        else {
                                mvdl("$name\_oases_k$k","assemble_$name/$name\_oases_k$k","Oases_$name\_k$k","oases.fasta","contig-ordering.txt");
                        }
                }
        }
	my @fas;
        for(my $k=$maxkmer;$k>=$minkmer;$k=$k-$kmerstep) {
        	push(@fas,"assemble_xxxname/xxxname_oases_k$k/oases.fasta")
        }
	if($bowtie2) {
		runBowtie2(\%fq,'Oases',$bowtie2dir,@fas);
	}
	if($croco==2&&(keys %fq)>1) {
                runCroCo(\%fq,'Oases',$crocodir,@fas);
        }
	$assemsw+=1;
}

if($abyss) {
	printf "Assembling by Trans-ABySS...\n";
        unless($exist) {
                my ($abysscommand,%cm);
		foreach my $name (keys %fq) {
                	for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
                        	$abysscommand="transabyss -k $k --outdir $name\_abyss_k$k --threads xxxcpu";
				if($bam) {
                        		$abysscommand.=" --$fq{$name}e bam/$name.bam 2>&1";
				}
				elsif($fq{$name} eq 'p') {
					$abysscommand.=" --pe $name.L.fastq $name.R.fastq 2>&1";
                		}
				elsif($fq{$name} eq 's') {
					$abysscommand.=" --se $name.fastq 2>&1";
                                }
				$cm{$abysscommand}="ABySS_$name\_k$k";
			}
		}
                runcmdpm(\%cm,$transabyssdir);
        }
	foreach my $name (keys %fq) {
                for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
                        if($exist&& -s "assemble_$name/$name\_abyss_k$k/abyss.fasta") {next;}
                        if($bam) {
				if($fq{$name} eq 'p') {
                                	runcmdrp("transabyss -k $k --pe bam/$name.bam --outdir $name\_abyss_k$k --threads $cpu 2>&1","$name\_abyss_k$k/transabyss-final.fa","$name\_abyss_k$k","ABySS_$name\_k$k",$transabyssdir);
                        	}
                        	elsif($fq{$name} eq 's') {
                                	runcmdrp("transabyss -k $k --se bam/$name.bam --outdir $name\_abyss_k$k --threads $cpu 2>&1","$name\_abyss_k$k/transabyss-final.fa","$name\_abyss_k$k","ABySS_$name\_k$k",$transabyssdir);
                        	}
			}
			elsif($fq{$name} eq 'p') {
                        	runcmdrp("transabyss -k $k --pe $name.L.fastq $name.R.fastq --outdir $name\_abyss_k$k --threads $cpu 2>&1","$name\_abyss_k$k/transabyss-final.fa","$name\_abyss_k$k","ABySS_$name\_k$k",$transabyssdir);
                        }
                        elsif($fq{$name} eq 's') {
                                runcmdrp("transabyss -k $k --se $name.fastq --outdir $name\_abyss_k$k --threads $cpu 2>&1","$name\_abyss_k$k/transabyss-final.fa","$name\_abyss_k$k","ABySS_$name\_k$k",$transabyssdir);
                        }
                        renameseq("$name\_abyss_k$k/transabyss-final.fa","$name\_abyss_k$k/abyss.fasta");
			if($noclean) {
                                runcmd("mv $name\_abyss_k$k assemble_$name/$name\_abyss_k$k","ABySS_$name\_k$k");
                        }
                        else {
                                mvdl("$name\_abyss_k$k","assemble_$name/$name\_abyss_k$k","ABySS_$name\_k$k","abyss.fasta");
                        }
		}
	}
	my @fas;
        for(my $k=$maxkmer;$k>=$minkmer;$k=$k-$kmerstep) {
        	push(@fas,"assemble_xxxname/xxxname_abyss_k$k/abyss.fasta")
        }
	if($bowtie2) {
                runBowtie2(\%fq,'ABySS',$bowtie2dir,@fas);
        }
	if($croco==2&&(keys %fq)>1) {
                runCroCo(\%fq,'ABySS',$crocodir,@fas);
        }
	$assemsw+=1;
}

if($idba) {
	if($bam) {die "\nError: IDBA-Tran assembly cannot be genome-guided!\n";}
        printf "Assembling by IDBA-Tran...\n";
        unless($exist) {
                my %cm;
                foreach my $name (keys %fq) {
                        if($fq{$name} eq 'p') {
                                $cm{"fq2fa --merge --filter $name.L.fastq $name.R.fastq assemble_$name/idba.fa 2>&1"}="IDBA_$name";
                        }
                        elsif($fq{$name} eq 's') {
                                $cm{"fq2fa --filter $name.fastq assemble_$name/idba.fa"}="IDBA_$name 2>&1";
                        }
                }
		runcmdpm(\%cm,$idbatrandir);
                %cm=();
                foreach my $name (keys %fq) {
                        for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
				$cm{"idba_tran --mink $k --maxk $k -r assemble_$name/idba.fa -o $name\_idba_k$k --num_threads xxxcpu 2>&1"}="IDBA_$name\_k$k";
                        }
                }
                runcmdpm(\%cm,$idbatrandir);
        }
	foreach my $name (keys %fq) {
                for(my $k=$minkmer;$k<=$maxkmer;$k=$k+$kmerstep) {
                        if($exist&& -s "assemble_$name/$name\_idba_k$k/idba.fasta") {next;}
			unless(-s "assemble_$name/idba.fa") {
                        	if($fq{$name} eq 'p') {
                                	runcmd("fq2fa --merge --filter $name.L.fastq $name.R.fastq assemble_$name/idba.fa 2>&1","IDBA_$name",$idbatrandir);
                        	}
                        	elsif($fq{$name} eq 's') {
                                	runcmd("fq2fa --filter $name.fastq assemble_$name/idba.fa 2>&1","IDBA_$name",$idbatrandir);
                        	}
			}
			runcmdrp("idba_tran --mink $k --maxk $k -r assemble_$name/idba.fa -o $name\_idba_k$k --num_threads $cpu 2>&1","$name\_idba_k$k/contig.fa","$name\_idba_k$k","IDBA_$name\_k$k",$idbatrandir);
                        renameseq("$name\_idba_k$k/contig.fa","$name\_idba_k$k/idba.fasta");
                        if($noclean) {
                                runcmd("mv $name\_idba_k$k assemble_$name/$name\_idba_k$k","IDBA_$name\_k$k");
                        }
                        else {
                                mvdl("$name\_idba_k$k","assemble_$name/$name\_idba_k$k","IDBA_$name\_k$k","idba.fasta","log");
                        }
		}
		unless($noclean) {
			unless($exist&& (! -s "assemble_$name/idba.fa")) {
				runcmd("rm assemble_$name/idba.fa","IDBA_$name");
			}
		}
	}
	my @fas;
	for(my $k=$maxkmer;$k>=$minkmer;$k=$k-$kmerstep) {
        	push(@fas,"assemble_xxxname/xxxname_idba_k$k/idba.fasta")
        }
	if($bowtie2) {
                runBowtie2(\%fq,'IDBA',$bowtie2dir,@fas);
        }
	if($croco==2&&(keys %fq)>1) {
                runCroCo(\%fq,'IDBA',$crocodir,@fas);
        }
        $assemsw+=1;
}

foreach my $name (keys %fq) {
	if($exist&& -s "$name.fasta") {next;}
	open(FAS,">$name.fasta") or die "\nError: fail to open '$name.fasta'!\n";
	close(FAS);
	if($croco==2&&(keys %fq)>1) {
		if($trinity) {runcmd("cat CroCo/Trinity_CroCo/$name\_clean.fasta >> $name.fasta",'sum_seq_assem');}
		if($soap) {runcmd("cat CroCo/Soap_CroCo/$name\_clean.fasta >> $name.fasta",'sum_seq_assem');}
		if($oases) {runcmd("cat CroCo/Oases_CroCo/$name\_clean.fasta >> $name.fasta",'sum_seq_assem');}
		if($abyss) {runcmd("cat CroCo/ABySS_CroCo/$name\_clean.fasta >> $name.fasta",'sum_seq_assem');}
		if($idba) {runcmd("cat CroCo/IDBA_CroCo/$name\_clean.fasta >> $name.fasta",'sum_seq_assem');}
	}
	else {
		if($trinity) {runcmd("cat assemble_$name/trinity_dir_$name/Trinity.fasta >> $name.fasta",'sum_seq_assem');}
		for(my $k=$maxkmer;$k>=$minkmer;$k=$k-$kmerstep) {
                        if($soap) {runcmd("cat assemble_$name/$name\_soap_k$k/soap.fasta >> $name.fasta",'sum_seq_assem');}
                        if($oases) {runcmd("cat assemble_$name/$name\_oases_k$k/oases.fasta >> $name.fasta",'sum_seq_assem');}
                        if($abyss) {runcmd("cat assemble_$name/$name\_abyss_k$k/abyss.fasta >> $name.fasta",'sum_seq_assem');}
                        if($idba) {runcmd("cat assemble_$name/$name\_idba_k$k/idba.fasta >> $name.fasta",'sum_seq_assem');}
		}
	}
}
if($bowtie2) {
	if($assemsw!=1) {
		printf "Assessing the read content of the final assemblies...\n";
		foreach my $name (keys %fq) {
			runcmd("bowtie2-build $name.fasta Bowtie2/all_$name 2>&1","Bowtie2_all_$name",$bowtie2dir);
			if($fq{$name} eq 'p') {
				runcmd("bowtie2 -x Bowtie2/all_$name -1 $name.L.fastq -2 $name.R.fastq -S Bowtie2/all_$name.sam -p $cpu -q --no-unal -k 20 2>&1","Bowtie2_all_$name",$bowtie2dir);
			}
			elsif($fq{$name} eq 's') {
                        	runcmd("bowtie2 -x Bowtie2/all_$name -U $name.fastq -S Bowtie2/all_$name.sam -p $cpu -q --no-unal -k 20 2>&1","Bowtie2_all_$name",$bowtie2dir);
                	}
			unless($noclean) {runcmd("rm Bowtie2/all_$name.sam","Bowtie2_all_$name");}
		}
	}
	unless($noclean) {runcmd("rm -rf Bowtie2","Bowtie2");}
}
my $result="xxxname.fasta";
printf "Assembling Complished!\n";
printf "The results are in the files 'xxxname.fasta'\n";
if($unigene) {printf "The unigenes of Trinity assemblies are in the files 'assemble_xxxname/trinity_dir_xxxname/unigene.fasta'\n";}
if($bowtie2) {printf "The read content assessments are in the files '$logdir/Bowtie2_xxx_xxxname.log'\n";}
printf "Checking the results...\n";
foreach my $name (keys %fq) {checkseq("$name.fasta",$minkmer,$maxkmer,$kmerstep,"$logdir/assemble.check.txt");}

if($croco==1&&(keys %fq)>1) {
	printf "Cleaning cross-contamination among all assemblies...\n";
	my $crocomode='s';
	my $skip=$exist;
	foreach my $name (keys %fq) {
        	if($fq{$name} eq 'p') {$crocomode='p';}
        	if($exist) {
                        if($crocofasta==2) {unless(-s "CroCo/all/$name\_clean.fasta") {$skip=0;}}
                        elsif(!(-s "CroCo/all/$name.all" && -s "CroCo/all/$name.all_quants")) {$skip=0;}
                }
        }
        if($exist&& (!(-s "CroCo/all/CroCo_summary"))) {$skip=0;}
	unless($skip) {
        	chdir("$crocodir") or die "\nError: fail to enter directory '$crocodir'!\n";
        	runcmd("bash src/CroCo_v1.1.sh --mode $crocomode --in $workdir --threads $cpu -l 1 --graph yes 2>&1","all_CroCo");
        	chdir("$workdir") or die "\nError: fail to enter directory '$workdir'!\n";
        	my $ccdir;
        	open(CC,"<$logdir/all_CroCo.log") or die "\nError: fail to open '$logdir/all_CroCo.log'!\n";
                while(<CC>) {
                        if($_=~s/^All results are in//) {
                                $ccdir=$_;
                                $ccdir=~s/^\s+//;
				$ccdir=~s/\s+$//;
                                last;
                        }
                }
                close(CC);
		if($noclean) {
                	runcmd("mv $ccdir CroCo/all","all_CroCo");
        	}
		else {
                        mvdl($ccdir,"CroCo/all","all_CroCo","CroCo_*","*.all","utility_files_CroCo/*.all_quants","network_*");
                }
	}
        if($crocofasta>1) {
                foreach my $name (keys %fq) {
                        runcmd("blastdbcmd.pl -i CroCo/all/$name.all -d $name.fasta -o CroCo/all/$name\_clean.fasta -t clean -l 999999999 2>&1","all_CroCo","$crocodir/src") unless ($exist&& (-s "CroCo/all/$name\_clean.fasta"));
                        if($crocofasta>2) {
                                foreach my $type ('contam','dubious','lowcov','overexp') {
                                        runcmd("blastdbcmd.pl -i CroCo/all/$name.all -d $name.fasta -o CroCo/all/$name\_$type.fasta -t $type -l 999999999 2>&1","all_CroCo","$crocodir/src") unless ($exist&& (-s "CroCo/all/$name\_$type.fasta"));
                                }
                        }
                }
        }
	printf "Cross-contamination cleaning Complished!\n";
	if($crocofasta>1) {
		$result="CroCo/all/xxxname_clean.fasta";
		printf "The results are in the files 'CroCo/all/xxxname_clean.fasta'\n";
		printf "Checking the results...\n";
		foreach my $name (keys %fq) {checkseq("CroCo/all/$name\_clean.fasta",$minkmer,$maxkmer,$kmerstep,"$logdir/croco.check.txt");}
	}
}

if($removecontam) {
	printf "Removing the outgroup contamination...\n";
	unless(-d "outgroup_clean") {mkdir("outgroup_clean") or die "\nError: fail to create the directory 'outgroup_clean'!\n";}
	my %cm;
	foreach my $name (keys %fq) {
		if($exist&& -s "outgroup_clean/$name.fasta" && -e "outgroup_clean/$name.ok") {next;}
		my $infile=$result;
                $infile=~s/xxxname/$name/g;
		my $removecommand;
		unless($exist&& -e "outgroup_clean/$name.in.out" && -e "outgroup_clean/$name.inblast.ok") {$removecommand.="$blastprog -db $ingroupdatabase -query $infile -outfmt '6 std staxids' -out outgroup_clean/$name.in.out -num_threads xxxcpu 2>&1 && touch outgroup_clean/$name.inblast.ok && ";}
		unless($exist&& -e "outgroup_clean/$name.out.out" && -e "outgroup_clean/$name.outblast.ok") {$removecommand.="$blastprog -db $outgroupdatabase -query $infile -outfmt '6 std staxids' -out outgroup_clean/$name.out.out -num_threads xxxcpu 2>&1 && touch outgroup_clean/$name.outblast.ok && ";}
		$removecommand.="$scriptdir/removecontam.pl -i $infile -a outgroup_clean/$name.in.out -b outgroup_clean/$name.out.out -o outgroup_clean/$name.fasta -c xxxcpu";
		if($removecontam eq '1') {$removecommand.=" -p 98 -k 80 -f 30 -g 10 -z 3";}
		elsif($removecontam eq '2') {$removecommand.=" -p 98 -q 10 -z 9";}
		else {$removecommand.=" $removecontam";}
		if($acc2tax) {$removecommand.=" -t $acc2tax";}
		unless($explist) {
			if($croco==1&&-s "CroCo/all/$name.all_quants") {runcmd("cp CroCo/all/$name.all_quants outgroup_clean/$name.all_quants","removecontam_$name");}
			elsif($croco==2&&(keys %fq)>1) {
				open(Q,">outgroup_clean/$name.all_quants") or die "\nError: fail to open 'outgroup_clean/$name.all_quants'!\n";
				close(Q);
                		if($trinity) {runcmd("cat CroCo/Trinity_CroCo/$name.all_quants >> outgroup_clean/$name.all_quants","removecontam_$name");}
                		if($soap) {runcmd("cat CroCo/Soap_CroCo/$name.all_quants >> outgroup_clean/$name.all_quants","removecontam_$name");}
                		if($oases) {runcmd("cat CroCo/Oases_CroCo/$name.all_quants >> outgroup_clean/$name.all_quants","removecontam_$name");}
                		if($abyss) {runcmd("cat CroCo/ABySS_CroCo/$name.all_quants >> outgroup_clean/$name.all_quants","removecontam_$name");}
                		if($idba) {runcmd("cat CroCo/IDBA_CroCo/$name.all_quants >> outgroup_clean/$name.all_quants","removecontam_$name");}
        		}
			if(-s "outgroup_clean/$name.all_quants") {$removecommand.=" -x outgroup_clean/$name.all_quants";}
		}
		elsif($explist ne '1') {$removecommand.=" -x $explist";}
		if($minexp) {$removecommand.=" -m $minexp";}
		if($exist) {$removecommand.=" -n";}
		$removecommand.=" 2>&1 && touch outgroup_clean/$name.ok";
		$cm{$removecommand}="removecontam_$name";
	}
	if((keys %cm)>0) {runcmdpm(\%cm);}
	foreach my $name (keys %fq) {
		unless(-s "outgroup_clean/$name.fasta" && -e "outgroup_clean/$name.ok") {
			my $infile=$result;
                        $infile=~s/xxxname/$name/g;
			unless(-e "outgroup_clean/$name.in.out" && -e "outgroup_clean/$name.inblast.ok") {runcmd("$blastprog -db $ingroupdatabase -query $infile -outfmt '6 std staxids' -out outgroup_clean/$name.in.out -num_threads $cpu 2>&1 && touch outgroup_clean/$name.inblast.ok","removecontam_$name");}
			unless(-e "outgroup_clean/$name.out.out" && -e "outgroup_clean/$name.outblast.ok") {runcmd("$blastprog -db $outgroupdatabase -query $infile -outfmt '6 std staxids' -out outgroup_clean/$name.out.out -num_threads $cpu 2>&1 && touch outgroup_clean/$name.outblast.ok","removecontam_$name");}
			my $removecommand="$scriptdir/removecontam.pl -i $infile -a outgroup_clean/$name.in.out -b outgroup_clean/$name.out.out -o outgroup_clean/$name.fasta -c $cpu -n";
			if($removecontam eq '1') {$removecommand.=" -p 98 -k 80 -f 30 -g 10 -z 3";}
			elsif($removecontam eq '2') {$removecommand.=" -p 98 -q 10 -z 9";}
			else {$removecommand.=" $removecontam";}
                	if($acc2tax) {$removecommand.=" -t $acc2tax";}
			unless($explist) {if(-s "outgroup_clean/$name.all_quants") {$removecommand.=" -x outgroup_clean/$name.all_quants";}}
			elsif($explist ne '1') {$removecommand.=" -x $explist";}
                	if($minexp) {$removecommand.=" -m $minexp";}
			$removecommand.=" 2>&1 && touch outgroup_clean/$name.ok";
			runcmd($removecommand,"removecontam_$name");
		}
		unless($noclean) {
			if(-e "outgroup_clean/$name.in.out") {runcmd("rm outgroup_clean/$name.in.out","removecontam_$name");}
			if(-e "outgroup_clean/$name.out.out") {runcmd("rm outgroup_clean/$name.out.out","removecontam_$name");}
			if(-e "outgroup_clean/$name.all_quants") {runcmd("rm outgroup_clean/$name.all_quants","removecontam_$name");}
			if(-e "outgroup_clean/$name.fasta.IN.gff3") {runcmd("rm outgroup_clean/$name.fasta.IN.gff3","removecontam_$name");}
			if(-e "outgroup_clean/$name.fasta.OUT.gff3") {runcmd("rm outgroup_clean/$name.fasta.OUT.gff3","removecontam_$name");}
		}
	}
	$result="outgroup_clean/xxxname.fasta";
	printf "Outgroup contamination Removing Complished!\n";
        printf "The results are in the files 'outgroup_clean/xxxname.fasta'\n";
	if($acc2tax) {printf "The species identifications are in the log files '$logdir/removecontam_xxxname.log'\n";}
        printf "Checking the results...\n";
        foreach my $name (keys %fq) {checkseq("outgroup_clean/$name.fasta",$minkmer,$maxkmer,$kmerstep,"$logdir/removecontam.check.txt");}
}

if($evigene) {
	printf "Conducting redundancy reduction and gene reconstruction...\n";
        unless(-d "evigene_result") {mkdir("evigene_result") or die "\nError: fail to create the directory 'evigene_result'!\n";}
	runcmd("cp -r $evidentialgenedir EvidentialGene; sed -i '/^ncpu=/c ncpu=$cpu' EvidentialGene/scripts/prot/tr2aacds_qsub.sh","EvidentialGene");
	foreach my $name (keys %fq) {
                if($exist&& -s "evigene_result/$name/okayset/$name.okay.fasta") {next;}
                my $infile=$result;
                $infile=~s/xxxname/$name/g;
		unless(-d "evigene_result/cds_$name") {mkdir("evigene_result/cds_$name") or die "\nError: fail to create the directory 'evigene_result/cds_$name'!\n";}
		runcmd("cp $infile evigene_result/cds_$name/$name.fasta","EvidentialGene_$name");
		runcmd("env trset=$workdir/evigene_result/cds_$name/$name.fasta datad=$workdir/evigene_result/cds_$name EvidentialGene/scripts/prot/tr2aacds_qsub.sh 2>&1","EvidentialGene_$name");
		if($noclean) {
                        runcmd("mv evigene_result/cds_$name evigene_result/$name","EvidentialGene_$name");
                }
                else {
                        mvdl("evigene_result/cds_$name","evigene_result/$name","EvidentialGene_$name","okayset","$name.trclass","$name.trclass.sum.txt","$name.tr2aacds.log");
                }
	}
	unless($noclean) {runcmd("rm -r EvidentialGene","EvidentialGene");}
	$result="evigene_result/xxxname/okayset/xxxname.okay.fasta";
        printf "Redundancy reduction and gene reconstruction Complished!\n";
        printf "The results are in the files 'evigene_result/xxxname/okayset/xxxname.okay.fasta|aa|cds'\n";
        printf "Checking the results...\n";
        foreach my $name (keys %fq) {checkseq("evigene_result/$name/okayset/$name.okay.fasta",$minkmer,$maxkmer,$kmerstep,"$logdir/EvidentialGene.check.txt");}
}

sub runcmd {
open(LOG,">>$logdir/$_[1].log") or die "\nError: fail to open '$logdir/$_[1].log'!\n";
if($_[2]) {
        printf "Setting PATH: +$_[2]\n";
        print LOG "Setting PATH: +$_[2]\n";
        $ENV{'PATH'}.=":$_[2]";
}
printf "$_[0]\n";
print LOG "$_[0]\n";
my ($iferr,$ifwarn,$templog);
$templog=`$_[0]`;
$iferr=$?;
printf $templog;
print LOG $templog;
close(LOG);
if($templog=~/error/i || $templog=~/fault/i || $templog=~/warn/i || $templog=~/sh: line/) {$ifwarn=1;}
if($iferr) {die "\nError in '$_[0]', please check $logdir/$_[1].log!\n";}
if($ifwarn) {printf "\nWarning: there may be some errors or warnings in '$_[0]', please check $logdir/$_[1].log!\n";}
$ENV{'PATH'}=$path;
}

sub runcmdpm {
my $cmref=$_[0];
my %cm=%$cmref;
if($_[1]) {
        printf "Setting PATH: +$_[1]\n";
        $ENV{'PATH'}.=":$_[1]";
}
my $fqn=$parallel;
if($fqn>(keys %cm)) {$fqn=(keys %cm);}
my $ncpu=int($cpu/$fqn);
if($fqn>$cpu) {$fqn=$cpu;$ncpu=1;}
my $pm = new Parallel::ForkManager($fqn);
foreach my $command (keys %cm) {
	$pm->start and next;
	my $command0=$command;
	$command=~s/xxxcpu/$ncpu/g;
	open(LOG,">>$logdir/$cm{$command0}.log") or die "\nError: fail to open '$logdir/$cm{$command0}.log'!\n";
	if($_[1]) {print LOG "Setting PATH: +$_[1]\n";}
	printf "$command\n";
	print LOG "$command\n";
	my ($iferr,$ifwarn,$templog);
	$templog=`$command`;
	$iferr=$?;
	printf $templog;
	print LOG $templog;
	close(LOG);
	if($templog=~/error/i || $templog=~/fault/i || $templog=~/warn/i) {$ifwarn=1;}
	if($iferr) {printf "\nWarning: error in '$command'!\n";}
	elsif($ifwarn) {printf "\nWarning: there may be some errors or warnings in '$command', please check $logdir/$cm{$command0}.log!\n";}
	$pm->finish();
}
$pm->wait_all_children;
$ENV{'PATH'}=$path;
}

sub runcmdrp {
my $command=$_[0];
my $result=$_[1];
my $dir=$_[2];
my $cm=$_[3];
if($_[4]) {$command="export PATH=\$PATH:$_[4]; ".$command;}
my $rpnum=0;
while(!(-s $result)) {
	$rpnum+=1;
	if($rpnum>1) {die "\nError in '$command' after 1 retries, please check $logdir/$cm.log!\n";}
	printf "Retry $rpnum: $command\n";
	open(LOG0,">$logdir/$cm.log") or die "\nError: fail to open '$logdir/$cm.log'!\n";
	close(LOG0);
	if(-d $dir) {runcmd("rm -rf $dir",$cm);}
        open(LOG,">>$logdir/$cm.log") or die "\nError: fail to open '$logdir/$cm.log'!\n";
        printf "$command\n";
        print LOG "$command\n";
	my ($iferr,$ifwarn,$templog);
	$templog=`$command`;
        $iferr=$?;
        printf $templog;
        print LOG $templog;
        close(LOG);
        if($templog=~/error/i || $templog=~/fault/i || $templog=~/warn/i) {$ifwarn=1;}
        if($iferr) {printf "\nWarning: error in '$command'!\n";}
        elsif($ifwarn) {printf "\nWarning: there may be some errors or warnings in '$command', please check $logdir/$cm.log!\n";}
}
$ENV{'PATH'}=$path;
}

sub mvdl {
my $dir1=shift(@_);
my $dir2=shift(@_);
my $logname=shift(@_);
my @files=@_;
mkdir("$dir2") or die "\nError: fail to create the directory '$dir2'!\n";
my $mvword="mv";
for(my $i=0;$i<@files;$i++) {
	$mvword.=" $dir1/$files[$i]";
}
runcmd("$mvword $dir2",$logname);
runcmd("rm -rf $dir1",$logname);
}

sub runBowtie2 {
my $fqref=shift(@_);
my %fq=%$fqref;
my $cm=shift(@_);
my $bowtie2dir=shift(@_);
my @files=@_;
printf "Assessing the read content of the $cm assemblies...\n";
foreach my $name (keys %fq) {
	my $catword="cat";
	for(my $i=0;$i<@files;$i++) {
        	$catword.=" $files[$i]";
        }
        $catword=~s/xxxname/$name/g;
        runcmd("$catword >Bowtie2/$cm\_$name.fasta","Bowtie2_$cm\_$name");
	runcmd("bowtie2-build Bowtie2/$cm\_$name.fasta Bowtie2/$cm\_$name.fasta 2>&1","Bowtie2_$cm\_$name",$bowtie2dir);
	if($fq{$name} eq 'p') {
                runcmd("bowtie2 -x Bowtie2/$cm\_$name.fasta -1 $name.L.fastq -2 $name.R.fastq -S Bowtie2/$cm\_$name.sam -p $cpu -q --no-unal -k 20 2>&1","Bowtie2_$cm\_$name",$bowtie2dir);
        }
        elsif($fq{$name} eq 's') {
                runcmd("bowtie2 -x Bowtie2/$cm\_$name.fasta -U $name.fastq -S Bowtie2/$cm\_$name.sam -p $cpu -q --no-unal -k 20 2>&1","Bowtie2_$cm\_$name",$bowtie2dir);
        }
	unless($noclean) {runcmd("rm Bowtie2/$cm\_$name.*","Bowtie2_$cm\_$name");}
}
}

sub runCroCo {
my $fqref=shift(@_);
my %fq=%$fqref;
my $cm=shift(@_);
my $crocodir=shift(@_);
my @files=@_;
printf "Cleaning cross-contamination among $cm assemblies...\n";
my $crocomode='s';
my $skip=$exist;
foreach my $name (keys %fq) {
        if($fq{$name} eq 'p') {$crocomode='p';}
        if($exist) {
		if($crocofasta==2) {unless(-s "CroCo/$cm\_CroCo/$name\_clean.fasta") {$skip=0;}}
                elsif(!(-s "CroCo/$cm\_CroCo/$name.all" && -s "CroCo/$cm\_CroCo/$name.all_quants")) {$skip=0;}
        }
}
if($exist&& (!(-s "CroCo/$cm\_CroCo/CroCo_summary"))) {$skip=0;}
foreach my $name (keys %fq) {
        my $catword="cat";
        for(my $i=0;$i<@files;$i++) {
                $catword.=" $files[$i]";
        }
        $catword=~s/xxxname/$name/g;
        runcmd("$catword >$name.fasta","$cm\_CroCo");
}
unless($skip) {
        chdir("$crocodir") or die "\nError: fail to enter directory '$crocodir'!\n";
        runcmd("bash src/CroCo_v1.1.sh --mode $crocomode --in $workdir --threads $cpu -l 1 --graph yes 2>&1","$cm\_CroCo");
        chdir("$workdir") or die "\nError: fail to enter directory '$workdir'!\n";
        my $ccdir;
        open(CC,"<$logdir/$cm\_CroCo.log") or die "\nError: fail to open '$logdir/$cm\_CroCo.log'!\n";
        while(<CC>) {
                if($_=~s/^All results are in//) {
                        $ccdir=$_;
                        $ccdir=~s/^\s+//;
                        $ccdir=~s/\s+$//;
                        last;
                }
        }
        close(CC);
        if($noclean) {
                runcmd("mv $ccdir CroCo/$cm\_CroCo","$cm\_CroCo");
        }
        else {
                mvdl($ccdir,"CroCo/$cm\_CroCo","$cm\_CroCo","CroCo_*","*.all","utility_files_CroCo/*.all_quants","network_*");
        }
}
if($crocofasta>1) {
        foreach my $name (keys %fq) {
                runcmd("blastdbcmd.pl -i CroCo/$cm\_CroCo/$name.all -d $name.fasta -o CroCo/$cm\_CroCo/$name\_clean.fasta -t clean -l 999999999 2>&1","$cm\_CroCo","$crocodir/src") unless ($exist&& (-s "CroCo/$cm\_CroCo/$name\_clean.fasta"));
                if($crocofasta>2) {
                        foreach my $type ('contam','dubious','lowcov','overexp') {
                                runcmd("blastdbcmd.pl -i CroCo/$cm\_CroCo/$name.all -d $name.fasta -o CroCo/$cm\_CroCo/$name\_$type.fasta -t $type -l 999999999 2>&1","$cm\_CroCo","$crocodir/src") unless ($exist&& (-s "CroCo/$cm\_CroCo/$name\_$type.fasta"));
                        }
                }
        }
}
foreach my $name (keys %fq) {runcmd("rm $name.fasta","$cm\_CroCo");}
}

sub reconf {
my $input=$_[0];
my $output=$_[1];
my ($dir,$name);
if($output=~/(\S+)\/(\w+)\_soap.conf$/) {$dir=$1;$name=$2;}
else {die "\nFormat error: $output!\n";}
open(OUT,">$output") or die "\nError: $output can't open!\n";
if(-s "$input") {
        open(IN,"<$input") or die "\nError: $input can't open!\n";
        while(<IN>) {
                unless($_=~/^rank=/||$_=~/^pair_num_cutoff=/) {
                        if($_=~/^q1=/&&(!$bam)) {print OUT "q1=$dir/$name.L.fastq\n";}
                        elsif($_=~/^q2=/&&(!$bam)) {print OUT "q2=$dir/$name.R.fastq\n";}
                        elsif($_=~/^q=/&&(!$bam)) {print OUT "q=$dir/$name.fastq\n";}
                        else {print OUT $_;}
                }
        }
        close(IN);
}
else {
        printf "\nWarning: fail to found '$input', '$output' will be generated with default parameters!\n";
        print OUT "[LIB]\n";
        if($bam) {}
        elsif(-s "$dir/$name.L.fastq" && -s "$dir/$name.R.fastq") {print OUT "q1=$dir/$name.L.fastq\nq2=$dir/$name.R.fastq\n";}
        elsif(-s "$dir/$name.fastq") {print OUT "q=$dir/$name.fastq\n";}
        else {die "\nError: fail to found the FASTQs of $name!\n";}
}
if($bam) {print OUT "b=$dir/bam/$name.bam\n";}
close(OUT);
}

sub renameseq {
my $input=$_[0];
my $output=$_[1];
open(OUT,">$output") or die "\nError: $output can't open!\n";
open(IN,"<$input") or die "\nError: $input can't open!\n";
chomp(my @Data=<IN>);
close(IN);
my $prefix;
if($input=~/\_([a-zA-Z0-9]+\_k\d+)\//) {$prefix=$1;}
for(my $j=0;$j<@Data;$j++) {
	$Data[$j]=~s/^>/>$prefix\_/;
        print OUT $Data[$j],"\n";
}
close(OUT);
}

sub checkseq {
my $k=$_[1];
my $K=$_[2];
my $s=$_[3];
my ($all,$T,%S,%O,%A,%I,$percent);
open(CH,">>$_[4]") or die "\nError: $_[4] can't open!\n";
printf "$_[0]:\n";
print CH "$_[0]:\n";
open(F,"<$_[0]") or die "\nError: $_[0] can't open!\n";
while(<F>) {
	if($_=~/^>/) {
		if($_=~/^>TRINITY_/) {$T+=1;}
		elsif($_=~/^>soap_k(\d+)_/) {$S{$1}+=1;}
		elsif($_=~/^>oases_k(\d+)_/) {$O{$1}+=1;}
		elsif($_=~/^>abyss_k(\d+)_/) {$A{$1}+=1;}
		elsif($_=~/^>idba_k(\d+)_/) {$I{$1}+=1;}
		$all+=1;
	}
}
close(F);
printf "all: $all seqs\n";
print CH "all: $all seqs\n";
$percent=int($T*10000/$all)/100;
printf "trinity: $T seqs ($percent%)\n";
print CH "trinity: $T seqs ($percent%)\n";
for(my $x=$k;$x<=$K;$x=$x+$s) {
	$percent=int($S{$x}*10000/$all)/100;
	printf "soap_k$x: $S{$x} seqs ($percent%)\n";
	print CH "soap_k$x: $S{$x} seqs ($percent%)\n";
}
for(my $x=$k;$x<=$K;$x=$x+$s) {
	$percent=int($O{$x}*10000/$all)/100;
        printf "oases_k$x: $O{$x} seqs ($percent%)\n";
	print CH "oases_k$x: $O{$x} seqs ($percent%)\n";
}
for(my $x=$k;$x<=$K;$x=$x+$s) {
	$percent=int($A{$x}*10000/$all)/100;
        printf "abyss_k$x: $A{$x} seqs ($percent%)\n";
	print CH "abyss_k$x: $A{$x} seqs ($percent%)\n";
}
for(my $x=$k;$x<=$K;$x=$x+$s) {
	$percent=int($I{$x}*10000/$all)/100;
        printf "idba_k$x: $I{$x} seqs ($percent%)\n";
	print CH "idba_k$x: $I{$x} seqs ($percent%)\n";
}
printf "\n";
print CH "\n";
close(CH);
}

sub fastqcorrect {
my $id=$_[0];
my ($word1,$word2);
open(F1,"<$id\_1.fastq") or die "\nError: $id\_1.fastq can't open!\n";
while(<F1>) {
        chomp;
        if($_=~/\_(\w+)\/1$/) {$word1=$1;}
        last;
}
close(F1);
open(F2,"<$id\_2.fastq") or die "\nError: $id\_2.fastq can't open!\n";
while(<F2>) {
        chomp;
        if($_=~/\_(\w+)\/2$/) {$word2=$1;}
        last;
}
close(F2);
if($word1 ne $word2) {
        printf "Found '$word1' in $id\_1.fastq and '$word2' in $id\_2.fastq after SRA conversion, correcting the FASTQs...\n";
        open(F1,"<$id\_1.fastq") or die "\nError: $id\_1.fastq can't open!\n";
        open(L,">$id.L.fastq") or die "\nError: $id.L.fastq can't open!\n";
        while(<F1>) {
                chomp;
                my $line=$_;
                $line=~s/\_$word1\/1$/\/1/;
                print L "$line\n";
        }
        close(F1);
        close(L);
        open(F2,"<$id\_2.fastq") or die "\nError: $id\_2.fastq can't open!\n";
        open(R,">$id.R.fastq") or die "\nError: $id.R.fastq can't open!\n";
        while(<F2>) {
                chomp;
                my $line=$_;
                $line=~s/\_$word2\/2$/\/2/;
                print R "$line\n";
        }
        close(F2);
        close(R);
        runcmd("rm $id\_1.fastq $id\_2.fastq",'prepare');
}
else {
        runcmd("mv $id\_1.fastq $id.L.fastq; mv $id\_2.fastq $id.R.fastq",'prepare');
}
}
