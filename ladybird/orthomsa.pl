#!/usr/bin/env perl

use Getopt::Std;
use Parallel::ForkManager;
use Bio::Tools::CodonTable;
use Bio::AlignIO;
use strict;
our $linsi='/public/lihaosen/anaconda3/envs/HGTscan/bin/linsi';
our $trimal='/public/lihaosen/anaconda3/envs/HGTscan/bin/trimal';
our $iqtree='/public/lihaosen/anaconda3/envs/HGTscan/bin/iqtree2';
our $mare='/public/lihaosen/software/MARE_v0.1.2-rc/MARE';
our $Apro='java -Xmx50000M -D"java.library.path=/public/lihaosen/software/A-pro-master/ASTRAL-MP/lib" -jar /public/lihaosen/software/A-pro-master/ASTRAL-MP/astral.1.1.6.jar';
our $python="python3"; # installed 'ete3' module
our $orthofinder='/public/lihaosen/anaconda3/envs/orthofinder/bin/orthofinder';
our $orthofinderenv='/public/lihaosen/anaconda3/envs/orthofinder/bin';

my %opt=('p'=>8,'x'=>'.cds','r'=>'*','l'=>30,'g'=>50,'v'=>60,'f'=>'-','b'=>80);
getopts('d:o:p:c:x:r:l:g:v:f:u:y:b:ktnsmaeh',\%opt);
usage() if $opt{h};
my $orthodir=$opt{d};
my $outdir=$opt{o};
my $cpu=$opt{p};
my $cdsdir=$opt{c};
my $cdssuffix=$opt{x};
my $nocheck=$opt{k};
my $ter=$opt{r};
my $notrim=$opt{t};
my $trimlen=$opt{l};
my $gt=1-$opt{g}/100;
my $cons=$opt{v};
my $nucltree=$opt{n};
my $fillsym=$opt{f};
my $outgroup=$opt{u};
my $nospeciestree=$opt{s};
my $list4sptree=$opt{y};
my $nomare=$opt{m};
my $noastral=$opt{a};
my $support=$opt{b};
my $noofd=$opt{e};

sub usage {

die "
perl $0
Realign the sequences of the orthogroups by MAFFT-LINSI and rebuild the gene trees and species tree by IQ-TREE

Usage:
-d   the OrthoFinder result directory
-o   the output directory(default=the same as the OrthoFinder result directory and replace the original results, otherwise the step to rerun OrthoFinder to resolve the gene trees will be skipped)
-p   the maximum CPUs to be used(default=8)
-c   the directory containing the CDS FASTA files
-x   the suffix of the CDS FASTA files(default='.cds')
-k   skip the step to check if the CDS sequences match the protein sequences and simply pretreat them, recommended to skip if the CDS sequences have been pretreated (e.g. by orthogroup.pl)
-r   the termination symbol in the protein alignments, Usually '*', '.' or 'X'(default='*')
-t   not to trim the alignments by trimAl and directly use the MSAs generated by MAFFT-LINSI
-l   the minimum length of trimmed protein alignments by trimAl, if smaller than this value or lost any sequences, slightly trim the alignments of the columns with more than a specific percent(-g) of gaps(default=30)
-g   the maximum percent of gaps in the slight trim(default=50)
-v   the minimum percentage of the positions in the original alignment to conserve in the slight trim(default=60)
-n   use the CDSs to build the trees instead of the proteins
-f   the symbol to fill the gaps replacing dupliacted genes when connecting the selected orthogroups for species tree(default='-')
-u   the outgroup taxon (list) for species tree, seperated by comma(default=the same as the orginal OrthoFinder species tree)
-s   skip the step to build the species tree by IQ-TREE
-y   the list file containing one orthogroup ID per line to realign the sequences and rebuild the gene trees of the orthogroups selected for species tree, '1' means the orthogroups selected by OrthoFinder for species tree
-m   skip the step to reduce the protein matrix by MARE when building the species tree
-a   skip the step to build the species tree by ASTRAL-Pro
-b   the support threshold of the gene trees used by ASTRAL-Pro, only when all support values within a gene tree are higher than this value, this tree will be parsed to ASTRAL-Pro(default=80)
-e   skip the step to rerun OrthoFinder to resolve the gene trees
-h   this help message

Example:
Realign the MSAs of proteins and CDSs, rebuild the trees and replace the OrthoFinder results using 35 CPUs:
$0 -d orthodir -c cdsdir -x cdssuffix -p 35
Realign the MSAs, rebuild the trees using the CDSs, identify 'X' as the termination symbol in the protein alignments, silghtly trim the MSAs retaining the columns less than 80% gaps and finally retain more than 80% columns instead of trimAl, fill the duplicated genes as 'X', specify a two-taxa branch as the outgroup of the species tree, skip the step to rerun OrthoFinder, only parse gene trees with all support values >= 90 to ASTRAL-Pro and output the results to a new directory:
$0 -d orthodir -o outputdir -c cdsdir -x cdssuffix -p 35 -r X -l 999999 -g 80 -v 80 -n -f X -u taxa1,taxa2 -b 90 -e

";
}

die "\nError: no OrthoFinder directory was set!\n" unless $orthodir;
unless($orthodir=~/^\//) {$orthodir=$ENV{'PWD'}.'/'.$orthodir;}
unless($outdir) {$outdir=$orthodir;}
unless($outgroup) {$outgroup=findoutgroup("$orthodir/Species_Tree/SpeciesTree_rooted.txt");}
$outgroup="'$outgroup'";
if($outgroup=~s/,/','/g) {$outgroup="tree.get_common_ancestor($outgroup)";}
our $seqdir="$orthodir/Orthogroup_Sequences";
my @OGs;
if($list4sptree) {
	if($list4sptree eq '1') {$list4sptree="$orthodir/Species_Tree/Orthogroups_for_concatenated_alignment.txt";}
	elsif($list4sptree!~/^\//) {$list4sptree=$ENV{'PWD'}.'/'.$list4sptree;}
	@OGs=checknum($seqdir,"$outdir/ok",$list4sptree);
}
else {@OGs=checknum($seqdir,"$outdir/ok");}
my $oknum=pop(@OGs);
my $OGnum=int(@OGs);
printf "$OGnum OGs need to be realigned and used to rebuild trees\n";
our $sptreefile="$outdir/SpeciesTree_rooted.txt";
our $wdalndir="$orthodir/WorkingDirectory/Alignments_ids";
our $wdtreedir="$orthodir/WorkingDirectory/Trees_ids";
if($outdir eq $orthodir) {
	unless(-d "$outdir/ok") {
		if(-d "$orthodir/MultipleSequenceAlignments"&&system("mv $orthodir/MultipleSequenceAlignments $orthodir/MultipleSequenceAlignments0")) {die "\nError in 'mv $orthodir/MultipleSequenceAlignments $orthodir/MultipleSequenceAlignments0'!\n";}
		if(-d "$orthodir/Gene_Trees"&&system("mv $orthodir/Gene_Trees $orthodir/Gene_Trees0")) {die "\nError in 'mv $orthodir/Gene_Trees $orthodir/Gene_Trees0'!\n";}
		if(-d "$orthodir/WorkingDirectory/Alignments_ids"&&system("mv $orthodir/WorkingDirectory/Alignments_ids $orthodir/WorkingDirectory/Alignments_ids0")) {die "\nError in 'mv $orthodir/WorkingDirectory/Alignments_ids $orthodir/WorkingDirectory/Alignments_ids0'!\n";}
		if(-d "$orthodir/WorkingDirectory/Trees_ids"&&system("mv $orthodir/WorkingDirectory/Trees_ids $orthodir/WorkingDirectory/Trees_ids0")) {die "\nError in 'mv $orthodir/WorkingDirectory/Trees_ids $orthodir/WorkingDirectory/Trees_ids0'!\n";}
	}
	$sptreefile="$orthodir/Species_Tree/SpeciesTree_rooted.txt";
	unless(-d $wdalndir) {mkdir($wdalndir) or die "\nError: fail to create the directory '$wdalndir'!\n";}
        unless(-d $wdtreedir) {mkdir($wdtreedir) or die "\nError: fail to create the directory '$wdtreedir'!\n";}
}
else {
	unless($outdir=~/^\//) {$outdir=$ENV{'PWD'}.'/'.$outdir;}
	unless(-d $outdir) {mkdir($outdir) or die "\nError: fail to create the output directory '$outdir'!\n";}
        else {print "\nWarning: the output directory '$outdir' has existed, please ensure if you want to continue the previous run on the basis of this directory!\n";}
}
our $logdir="$outdir/log";
our $okdir="$outdir/ok";
our $msadir="$outdir/MultipleSequenceAlignments";
our $treedir="$outdir/Gene_Trees";
our $alndir="$outdir/AA_mafft";
our $iqtreedir="$outdir/iqtree";
our ($trimdir,$cdsseqdir,$cdsalndir,$cdstrimdir);
unless(-d $okdir) {mkdir($okdir) or die "\nError: fail to create the directory '$okdir'!\n";}
unless(-d $logdir) {mkdir($logdir) or die "\nError: fail to create the directory '$logdir'!\n";}
unless(-d $msadir) {mkdir($msadir) or die "\nError: fail to create the directory '$msadir'!\n";}
unless(-d $treedir) {mkdir($treedir) or die "\nError: fail to create the directory '$treedir'!\n";}
unless(-d $alndir) {mkdir($alndir) or die "\nError: fail to create the directory '$alndir'!\n";}
unless(-d $iqtreedir) {mkdir($iqtreedir) or die "\nError: fail to create the directory '$iqtreedir'!\n";}
unless($notrim) {
	$trimdir="$outdir/AA_trim";
	unless(-d $trimdir) {mkdir($trimdir) or die "\nError: fail to create the directory '$trimdir'!\n";}
}
if($cdsdir) {
	$cdsseqdir="$outdir/CDS_seq";
	$cdsalndir="$outdir/CDS_mafft";
	unless(-d $cdsseqdir) {mkdir($cdsseqdir) or die "\nError: fail to create the directory '$cdsseqdir'!\n";}
	unless(-d $cdsalndir) {mkdir($cdsalndir) or die "\nError: fail to create the directory '$cdsalndir'!\n";}
	unless($notrim) {
		$cdstrimdir="$outdir/CDS_trim";
		unless(-d $cdstrimdir) {mkdir($cdstrimdir) or die "\nError: fail to create the directory '$cdstrimdir'!\n";}
	}
}
my %sqid;
open(SQ,"<$orthodir/WorkingDirectory/SequenceIDs.txt") or die "\nError: fail to open $orthodir/WorkingDirectory/SequenceIDs.txt!\n";
while(<SQ>) {
	chomp;
        my @arr=split(': ',$_);
	$sqid{$arr[1]}=$arr[0];
}
close(SQ);

my @errs;
my $np=$cpu;
my $ncpu=1;
if($cpu>$OGnum&&$OGnum>0) {$np=$OGnum;$ncpu=int($cpu/$np);}
my $pm = new Parallel::ForkManager($np);
$pm -> run_on_finish( sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
        my @arr=@$data_structure_reference;
	printf $arr[0];
        if($arr[1]) {push(@errs,$arr[1]);}
    });
for(my $i=0;$i<$OGnum;$i++) {
	$pm->start and next;
	my $OG=$OGs[$i];
	my ($outstr,$aln4tree,$seqnum);
	open(SEQ,"<$seqdir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $seqdir/$OG.fa!\n"]);
	while(<SEQ>) {if($_=~/^>/) {$seqnum+=1;}}
	close(SEQ);
	if($seqnum<2) {
		my ($seqid,$str,$nnstr,$nnseq,$taxa);
                open(IN,"<$seqdir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $seqdir/$OG.fa!\n"]);
                open(OUT,">$cdsseqdir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $cdsseqdir/$OG.fa!\n"]);
                while(my $line=<IN>) {
                        if($line=~/^>(\w+)\.(\S+)/) {
                                $taxa=$1;
                                $seqid="$taxa.$2";
                                print OUT ">$seqid\n";
                                my $iftarget=0;
                                open(C,"<$cdsdir/$taxa.cds") or $pm->finish(0,[$outstr,"\nError: fail to open $cdsdir/$taxa.cds!\n"]);
                                while(<C>) {
                                        chomp;
                                        if($_=~/^>(\S+)/) {
                                                if($iftarget) {last;}
                                                if($1 eq $seqid) {$iftarget=1;}
                                        }
                                        elsif($iftarget) {$nnstr.=$_;}
                                }
                                close(C);
				unless($nnstr) {$pm->finish(0,[$outstr,"\nError: fail to find $seqid in $cdsdir/$taxa.cds!\n"]);}
                        }
                        else {$line=~s/\s//g;$str.=$line;}
                }
		if($nocheck) {$nnseq=$nnstr;}
                else {($nnseq,$outstr)=checktranslate($str,$nnstr,$ter,"$OG-$seqid",$outstr,$pm);}
                print OUT "$nnseq\n";
                close(IN);
                close(OUT);
		open(OK,">$okdir/$OG.ok") or $pm->finish(0,[$outstr,"\nError: fail to open $okdir/$OG.ok!\n"]);
        	close(OK);
        	$pm->finish(0,[$outstr]);
	}

	$outstr=runcmd("$linsi --thread $ncpu $seqdir/$OG.fa > $alndir/$OG.fa",$OG,$pm,$outstr);
	if($cdsdir) {
		$outstr.="Aligning CDSs in $OG based on the protein MSA...\n";
		my ($seqid,$str,$nnstr,$nnseq,$taxa);
		open(IN,"<$alndir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $alndir/$OG.fa!\n"]);
        	open(OUT,">$cdsseqdir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $cdsseqdir/$OG.fa!\n"]);
        	while(my $line=<IN>) {
                	if($line=~/^>(\w+)\.(\S+)/) {
                        	my $previd="$OG-$seqid";
                        	$taxa=$1;
                        	$seqid="$taxa.$2";
				if($nocheck) {$nnseq=$nnstr;}
                        	else {($nnseq,$outstr)=checktranslate($str,$nnstr,$ter,$previd,$outstr,$pm);}
                        	if($nnseq) {print OUT "$nnseq\n>$seqid\n";}
                        	else {print OUT ">$seqid\n";}
                        	$nnstr="";
                        	$str="";
                        	my $iftarget=0;
                        	open(C,"<$cdsdir/$taxa.cds") or $pm->finish(0,[$outstr,"\nError: fail to open $cdsdir/$taxa.cds!\n"]);
                        	while(<C>) {
                                	chomp;
                                	if($_=~/^>(\S+)/) {
                                        	if($iftarget) {last;}
                                        	if($1 eq $seqid) {$iftarget=1;}
                                	}
                                	elsif($iftarget) {$nnstr.=$_;}
                        	}
                        	close(C);
                        	unless($nnstr) {$pm->finish(0,[$outstr,"\nError: fail to find $seqid in $cdsdir/$taxa.cds!\n"]);}
                	}
                	else {$line=~s/\s//g;$str.=$line;}
        	}
		if($nocheck) {$nnseq=$nnstr;}
        	else {($nnseq,$outstr)=checktranslate($str,$nnstr,$ter,"$OG-$seqid",$outstr,$pm);}
        	print OUT "$nnseq\n";
        	close(IN);
        	close(OUT);
		$outstr=runcmd("$trimal -in $alndir/$OG.fa -out $cdsalndir/$OG.fa -backtrans $cdsseqdir/$OG.fa -keepheader",$OG,$pm,$outstr);
	}

	if($notrim) {
		$outstr=runcmd("mv $alndir/$OG.fa $msadir/$OG.fa",$OG,$pm,$outstr);
		if($cdsdir&&$nucltree) {$aln4tree="$cdsalndir/$OG.fa";}
		else {$aln4tree="$msadir/$OG.fa";}
	}
	else {
		$outstr=runcmd("$trimal -in $alndir/$OG.fa -out $trimdir/$OG.fa -automated1 -keepheader",$OG,$pm,$outstr);
		my $alnlen=0;
		my $trimseqnum=0;
		if(-e "$trimdir/$OG.fa") {
			open(T,"<$trimdir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $trimdir/$OG.fa!\n"]);
                        while(<T>) {
                                chomp;
                                if($_=~/^>(\S+)/) {
                                        $trimseqnum+=1;
                                }
                                elsif($trimseqnum==1) {$alnlen+=length($_);}
                        }
                        close(T);
		}
		else {
			open(EMPTY,">$trimdir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $trimdir/$OG.fa!\n"]);
			close(EMPTY);
		}
		if($alnlen>=$trimlen&&$trimseqnum==$seqnum) {
			$outstr=runcmd("cp $trimdir/$OG.fa $msadir/$OG.fa",$OG,$pm,$outstr);
			if($cdsdir) {
				$outstr=runcmd("$trimal -in $alndir/$OG.fa -out $cdstrimdir/$OG.fa -backtrans $cdsseqdir/$OG.fa -automated1 -keepheader",$OG,$pm,$outstr);
			}
		}
		else {
			$outstr=runcmd("$trimal -in $alndir/$OG.fa -out $msadir/$OG.fa -gt $gt -cons $cons -keepheader",$OG,$pm,$outstr);
			if($cdsdir) {
				$outstr=runcmd("$trimal -in $alndir/$OG.fa -out $cdstrimdir/$OG.fa -backtrans $cdsseqdir/$OG.fa -gt $gt -cons $cons -keepheader",$OG,$pm,$outstr);
			}
		}
		if($cdsdir&&$nucltree) {$aln4tree="$cdstrimdir/$OG.fa";}
                else {$aln4tree="$msadir/$OG.fa";}
	}

	my $msaseqnum=0;
	open(MSAIN,"<$msadir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $msadir/$OG.fa!\n"]);
	if($outdir eq $orthodir) {open(MSAOUT,">$wdalndir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $wdalndir/$OG.fa!\n"]);}
        while(<MSAIN>) {
                if($_=~/^>(\S+)/) {
			my $oldid=$1;
			if($outdir eq $orthodir) {
                        	unless($sqid{$oldid}) {$pm->finish(0,[$outstr,"\nError: fail to find the OrthoFinder sequence ID of '$oldid'!\n"]);}
				print MSAOUT ">$sqid{$oldid}\n";
			}
			$msaseqnum+=1;
                }
                elsif($outdir eq $orthodir) {print MSAOUT $_;}
        }
        close(MSAIN);
	if($outdir eq $orthodir) {close(MSAOUT);}

	if($msaseqnum>2) {
		$outstr=runcmd("cp $aln4tree $iqtreedir/$OG.fa",$OG,$pm,$outstr);
		my $iqtreecmd="$iqtree -s $iqtreedir/$OG.fa --prefix $iqtreedir/$OG -T AUTO --threads-max $ncpu -keep-ident";
		if($cdsdir&&$nucltree) {
			my $alnlen=0;
			open(IQ,"<$iqtreedir/$OG.fa") or $pm->finish(0,[$outstr,"\nError: fail to open $iqtreedir/$OG.fa!\n"]);
                	while(<IQ>) {
                        	chomp;
                        	if($_=~/^>(\S+)/) {
                                	if($alnlen) {last;}
                        	}
                        	else {$alnlen+=length($_);}
                	}
                	close(IQ);
			open(POUT,">$iqtreedir/$OG.part.nexus") or $pm->finish(0,[$outstr,"\nError: fail to open $iqtreedir/$OG.part.nexus!\n"]);
			print POUT "#nexus\nbegin sets;\n\tcharset condon1 = 1-$alnlen\\3;\n\tcharset codon2 = 2-$alnlen\\3;\n\tcharset codon3 = 3-$alnlen\\3;\nend;\n";
			close(POUT);
			$iqtreecmd.=" -p $iqtreedir/$OG.part.nexus -m MFP+MERGE";
		}
		if($msaseqnum>3) {$outstr=runcmd("$iqtreecmd -B 1000",$OG,$pm,$outstr);}
		else {$outstr=runcmd($iqtreecmd,$OG,$pm,$outstr);}
		$outstr=runcmd("mv $iqtreedir/$OG.treefile $treedir/$OG"."_tree.txt",$OG,$pm,$outstr);

		if($outdir eq $orthodir) {
			open(TIN,"<$treedir/$OG"."_tree.txt") or $pm->finish(0,[$outstr,"\nError: fail to open $treedir/$OG"."_tree.txt!\n"]);
        		open(TOUT,">$wdtreedir/$OG"."_tree_id.txt") or $pm->finish(0,[$outstr,"\nError: fail to open $wdtreedir/$OG"."_tree_id.txt!\n"]);
        		while(<TIN>) {
				$_=~s/\(([^\(,:]+):/($sqid{$1}:/g;
				$_=~s/,([^\(,:]+):/,$sqid{$1}:/g;
				print TOUT $_;
        		}
        		close(TIN);
        		close(TOUT);
		}
	}

	open(OK,">$okdir/$OG.ok") or $pm->finish(0,[$outstr,"\nError: fail to open $okdir/$OG.ok!\n"]);
	close(OK);
	$pm->finish(0,[$outstr]);
}
$pm->wait_all_children;
my $errnum=int(@errs);
@OGs=();
if($list4sptree) {@OGs=checknum($seqdir,"$outdir/ok",$list4sptree);}
else {@OGs=checknum($seqdir,"$outdir/ok");}
$oknum=pop(@OGs);
my $nofinishnum=int(@OGs);
my $finishnum = $OGnum - $nofinishnum;
if($OGnum>0) {printf "Successful OGs: $finishnum;   Failed OGs: $nofinishnum\n";}
if($nofinishnum>0) {
	print "Failed OGs: ".join(',',@OGs)."\n";
	printf "Error message:\n";
	for(my $i=0;$i<$errnum;$i++) {
		printf $errs[$i];
	}
	die;
}

if($notrim) {if(-d $alndir) {rmdir($alndir) or die "\nError: fail to delete the directory '$alndir'!\n";}}
elsif(!-e "$okdir/print_trimal_method.ok") {
	open(TM,">$msadir/trimal.method.tsv") or die "\nError: fail to open '$msadir/trimal.method.tsv'!\n";
	opendir(DIR,$msadir) or die "\nError: fail to open the directory '$msadir'!\n";
	my @files=readdir(DIR);
	closedir(DIR);
	@files=sort @files;
	for(my $i=0;$i<@files;$i++) {
		my $file=$files[$i];
        	unless($file=~s/\.fa$//) {next;}
		if(`md5sum $msadir/$file.fa | cut -d " " -f 1` eq `md5sum $trimdir/$file.fa | cut -d " " -f 1`) {
			print TM "$file\tautomated1\n";
		}
		else {print TM "$file\tgt=$gt,cons=$cons\n";};
	}
	close(TM);
	open(OK,">$okdir/print_trimal_method.ok") or die "\nError: fail to open $okdir/print_trimal_method.ok!\n";
        close(OK);
}

unless($nospeciestree||-e "$okdir/species_tree.ok") {
my (@sps,$allaln,%spmsa);
open(SP,"<$orthodir/WorkingDirectory/SpeciesIDs.txt") or die "\nError: fail to open '$orthodir/WorkingDirectory/SpeciesIDs.txt'!\n";
while(<SP>) {
        chomp;
        if($_=~/(\d+): (\w+)\./) {push(@sps,$2);}
}
close(SP);
@OGs=();
open(CON,"<$list4sptree") or die "\nError: fail to open $list4sptree!\n";
while(<CON>) {
	chomp;
	push(@OGs,$_);
}
close(CON);
$OGnum=int(@OGs);
printf "Rebuilding species tree based on $OGnum OGs...\n";
my $partfile="$iqtreedir/SpeciesTreeAlignment.charset4mare.txt";
if($cdsdir&&$nucltree||$nomare) {$partfile="$iqtreedir/SpeciesTreeAlignment.part.nexus";}
open(PART,">$partfile") or die "\nError: fail to open '$partfile'!\n";
if($cdsdir&&$nucltree||$nomare) {print PART "#nexus\nbegin sets;\n";}
my $end=0;
for(my $i=0;$i<$OGnum;$i++) {
	my $OGfile="$msadir/$OGs[$i].fa";
	if($cdsdir&&$nucltree) {
		if($notrim) {$OGfile="$cdsalndir/$OGs[$i].fa";}
		else {$OGfile="$cdstrimdir/$OGs[$i].fa";}
	}
	my $alnIN = Bio::AlignIO->new(-file => "$OGfile");
        my $aln = $alnIN->next_aln();
        my $alnlen = $aln->length();
	my $alnnum=$aln->num_sequences;
	my %spnum;
	for(my $j=1;$j<=$alnnum;$j++) {
        	my $seq=$aln->get_seq_by_pos($j);
		my $seqid=$seq->display_id;
        	if($seqid=~/^(\w+)\./) {$spnum{$1}+=1;}
    	}
	my $aln2=Bio::SimpleAlign->new();
	foreach my $sp (@sps) {
		if($spnum{$sp}==1) {
			my $spq=quotemeta $sp;
			for(my $j=1;$j<=$alnnum;$j++) {
                		my $seq=$aln->get_seq_by_pos($j);
                		my $seqid=$seq->display_id;
                		if($seqid=~/^$spq\./) {
					$aln2->add_seq($seq);
					last;
				}
        		}
		}
	}
	$aln2=$aln2->remove_columns(['all_gaps_columns']);
	my $alnlen2 = $aln2->length();
	foreach my $sp (@sps) {
                if($spnum{$sp}==1) {
                        my $spq=quotemeta $sp;
                        for(my $j=1;$j<=$aln2->num_sequences;$j++) {
                                my $seq=$aln2->get_seq_by_pos($j);
                                my $seqid=$seq->display_id;
                                if($seqid=~/^$spq\./) {
                                        $spmsa{$sp}.=$seq->seq;
                                        last;
                                }
                        }
                }
		elsif($spnum{$sp}>1) {$spmsa{$sp}.=($fillsym x $alnlen2);}
                else {$spmsa{$sp}.=('-' x $alnlen2);}
        }
	my $start=$end+1;
	$end=$end+$alnlen2;
	if($cdsdir&&$nucltree) {
		print PART "\tcharset $OGs[$i]codon1 = $start-$end\\3;\n";
		$start+=1;
		print PART "\tcharset $OGs[$i]codon2 = $start-$end\\3;\n";
		$start+=1;
		print PART "\tcharset $OGs[$i]codon3 = $start-$end\\3;\n";
	}
	else {print PART "\tcharset $OGs[$i] = $start-$end;\n";}
}
if($cdsdir&&$nucltree||$nomare) {print PART "end;\n";}
close(PART);
my $msafile="$iqtreedir/SpeciesTreeAlignment.fa";
open(MSA,">$msafile") or die "\nError: fail to open '$msafile'!\n";
foreach my $sp (@sps) {print MSA ">$sp\n$spmsa{$sp}\n";}
close(MSA);
unless($cdsdir&&$nucltree||$nomare) {
	runcmd("cd $iqtreedir && $mare SpeciesTreeAlignment.charset4mare.txt SpeciesTreeAlignment.fa -m && mv results $iqtreedir/mare_results","species_tree");
	my $alnIN = Bio::AlignIO->new(-file => "$iqtreedir/mare_results/SpeciesTreeAlignment.fa_reduced");
        my $aln = $alnIN->next_aln();
        my $alnnum=$aln->num_sequences;
	unless($alnnum==@sps) {die "\nError: the number of sequences in '$iqtreedir/mare_results/SpeciesTreeAlignment.fa_reduced'($alnnum) does not equal the number of species in '$orthodir', it seems that some species were reduced by MARE, please check the MARE results in '$iqtreedir/mare_results'!\n";}
	$partfile="$iqtreedir/SpeciesTreeAlignment.part.reduced.nexus";
	open(RPART,">$partfile") or die "\nError: fail to open '$partfile'!\n";
	print RPART "#nexus\nbegin sets;\n";
	open(REDU,"<$iqtreedir/mare_results/SpeciesTreeAlignment.charset4mare.txt_reduced") or die "\nError: fail to open '$iqtreedir/mare_results/SpeciesTreeAlignment.charset4mare.txt_reduced'!\n";
	while(<REDU>) {print RPART $_;}
	close(REDU);
	print RPART "end;\n";
	close(RPART);
	$msafile="$iqtreedir/SpeciesTreeAlignment.reduced.fa";
	runcmd("cp $iqtreedir/mare_results/SpeciesTreeAlignment.fa_reduced $msafile","species_tree");
}
runcmd("$iqtree -s $msafile -p $partfile -m MFP+MERGE -B 1000 -T AUTO --threads-max $cpu --prefix $iqtreedir/SpeciesTreeAlignment -keep-ident","species_tree");
if($outdir eq $orthodir) {
	unless($cdsdir&&$nucltree) {runcmd("cp $msafile $msadir/SpeciesTreeAlignment.fa","species_tree");}
        if(-e "$orthodir/Species_Tree/SpeciesTree_rooted.txt"&&system("mv $orthodir/Species_Tree/SpeciesTree_rooted.txt $orthodir/Species_Tree/SpeciesTree_rooted.txt0")) {die "\nError in 'mv $orthodir/Species_Tree/SpeciesTree_rooted.txt $orthodir/Species_Tree/SpeciesTree_rooted.txt0'!\n";}
}
runcmd("$python -c \"from ete3 import Tree\ntree = Tree('$iqtreedir/SpeciesTreeAlignment.treefile')\ntree.set_outgroup($outgroup)\ntree.write(outfile='$sptreefile')\"","species_tree");
open(OK,">$okdir/species_tree.ok") or die "\nError: fail to open $okdir/species_tree.ok!\n";
close(OK);
}

unless($noastral||-e "$okdir/astral_pro.ok") {
	unless(-d "$outdir/astral_pro") {mkdir("$outdir/astral_pro") or die "\nError: fail to create the directory '$outdir/astral_pro'!\n";}
	chdir("$outdir/astral_pro") or die "\nError: fail to enter the directory '$outdir/astral_pro'!\n";
	@OGs=();
	open(CON,"<$list4sptree") or die "\nError: fail to open $list4sptree!\n";
	while(<CON>) {
		chomp;
		push(@OGs,$_);
	}
	close(CON);
	opendir(TDIR,$treedir) or die "\nError: fail to open the directory '$treedir'!\n";
        my @files=readdir(TDIR);
	closedir(TDIR);
	my $n=0;
	open(OGL,">Orthogroups_for_astral.txt") or die "\nError: fail to open Orthogroups_for_astral.txt!\n";
	open(GOUT,">gene_trees.txt") or die "\nError: fail to open gene_trees.txt!\n";
        foreach my $file (@files) {
                unless($file=~s/_tree\.txt$//) {next;}
		if($list4sptree&&(!($file~~@OGs))) {next;}
		my $ifsupport=0;
		my $lowsupport=0;
		open(GIN,"<$treedir/$file"."_tree.txt") or die "\nError: fail to open $treedir/$file"."_tree.txt!\n";
		while(my $tree=<GIN>) {
			$tree=~s/\s//g;
			my @arr=split('',$tree);
			for(my $i=0;$i<@arr-2;$i++) {
        			if($arr[$i] ne ')') {next;}
				if(substr($tree,$i+1)=~/^([\w\.]+)/) {
					my $ufb=$1;
					$ifsupport=1;
					if($ufb<$support) {$lowsupport=1;last;}
				}
			}
			if($ifsupport&&$lowsupport==0) {
				print GOUT "$tree\n";
				print OGL "$file\n";
				$n+=1;
				last;
			}
		}
		close(GIN);
	}
	close(GOUT);
	close(OGL);
	if($n==0) {die "\nError: no available gene trees with all support values >= $support can be used for ASTRAL-Pro!\n"}
        else {printf "$n gene trees were parsed to ASTRAL-Pro\n";}
	open(MAP,">gene2species.tsv") or die "\nError: fail to open gene2species.tsv!\n";
	foreach my $gene (keys %sqid) {
		my @arr=split(/\./,$gene);
		print MAP "$gene\t$arr[0]\n";
	}
	close(MAP);
	runcmd("$Apro -i gene_trees.txt -a gene2species.tsv -o SpeciesTree.txt -T $cpu","astral_pro");
	my $pythoncmd="from ete3 import Tree\ntree = Tree('SpeciesTree.txt')\ntree.set_outgroup($outgroup)";
	if($nospeciestree) {
		runcmd("$python -c \"$pythoncmd\ntree.write(outfile='$sptreefile')\"","astral_pro");
		open(OK,">$okdir/astral_pro.ok") or die "\nError: fail to open $okdir/astral_pro.ok!\n";
        	close(OK);
	}
	else {
		my $logtext=runcmd("$python -c \"$pythoncmd\ntree.write(outfile='SpeciesTree.rooted.txt')\niqtree = Tree('$sptreefile')\nrf, max_rf, common_leaves, parts_t1, parts_t2, discarded1, discarded2 = iqtree.robinson_foulds(tree)\nif rf > 0:\n    print('RF distance is', rf, 'over a total of', max_rf)\n    print('Partitions in A-Pro tree that were not found in IQ-TREE tree:', parts_t1 - parts_t2)\n    print('Partitions in IQ-TREE tree that were not found in A-Pro tree:', parts_t2 - parts_t1)\"","astral_pro");
		open(OK,">$okdir/astral_pro.ok") or die "\nError: fail to open $okdir/astral_pro.ok!\n";
        	close(OK);
		if($logtext=~/RF distance/) {
			printf "\nWarning: the topologies of the species trees built by IQ-TREE('$sptreefile') and ASTRAL-Pro('$outdir/astral_pro/SpeciesTree.rooted.txt') are different, please check them and select a better one to replaced with '$sptreefile'(just rename the original file), and then rerun the same command if you want to continue to rerun OrthoFinder to resolve the gene trees!\n";
			exit;
		}
	}
}

unless($outdir ne $orthodir||$noofd||-e "$okdir/orthofinder_resolve.ok") {
	$ENV{'PATH'}="$orthofinderenv:$ENV{'PATH'}";
        my $logtext=runcmd("$orthofinder -s $orthodir/Species_Tree/SpeciesTree_rooted.txt -ft $orthodir -t $cpu -X","orthofinder_resolve");
        my $resolvedir;
        if($logtext=~/Species-by-species orthologues directory:\s+(\S+)\/Orthologues\//) {$resolvedir=$1;}
	elsif($logtext=~/Results:\s+(\S+)\//) {$resolvedir=$1;}
        else {die "\nError: fail to find the new OrthoFinder output directory, please check $logdir/orthofinder_resolve.log!\n";}
        opendir(OFDIR,$resolvedir) or die "\nError: fail to open the directory '$resolvedir'!\n";
        my @files=readdir(OFDIR);
        closedir(OFDIR);
        foreach my $file (@files) {
                if($file=~/^\.+$/) {next;}
		if($file eq 'Species_Tree'||$file eq 'WorkingDirectory'||$file eq 'Log.txt') {
			runcmd("mv $resolvedir/$file $orthodir/$file"."1","orthofinder_resolve");
		}
		else {
                	if(-e "$orthodir/$file"&&system("mv $orthodir/$file $orthodir/$file"."0")) {die "\nError in 'mv $orthodir/$file $orthodir/$file"."0'!\n";}
                	runcmd("mv $resolvedir/$file $orthodir/$file","orthofinder_resolve");
		}
        }
        rmdir($resolvedir) or die "\nError: fail to delete the directory '$resolvedir'!\n";
        open(OK,">$okdir/orthofinder_resolve.ok") or die "\nError: fail to open $okdir/orthofinder_resolve.ok!\n";
        close(OK);
}


sub findoutgroup {
my ($outgroup,$tree,$br1,$br2,@brs1,@brs2);
open(TREE,"<$_[0]") or open(TREE,"<$_[0]0") or die "\nError: fail to open '$_[0]'!\n";
while(<TREE>) {$tree=$_;last;}
close(TREE);
$tree=~s/\s//g;
$tree=~s/\)[\w\.]+/\)/g;
my $bl=0;
my @arr=split('',$tree);
for(my $i=0;$i<@arr-2;$i++) {
        if($arr[$i] eq '(') {$bl+=1;}
	elsif($arr[$i] eq ')') {$bl-=1;}
	elsif($arr[$i] eq ','&&$bl==1) {
		$br1=substr($tree,0,$i);
		$br2=substr($tree,$i+1);
		last;
	}
}
my @sp1=split(/[\(\),;]+/,$br1);
foreach my $sp (@sp1) {
        if($sp&&$sp!~/^:/) {$sp=~s/:[e0-9\.\-]+$//;push(@brs1,$sp);}
}
my @sp2=split(/[\(\),;]+/,$br2);
foreach my $sp (@sp2) {
        if($sp&&$sp!~/^:/) {$sp=~s/:[e0-9\.\-]+$//;push(@brs2,$sp);}
}
if(int(@brs1)>int(@brs2)) {$outgroup=join(',',@brs2);}
else {$outgroup=join(',',@brs1);}
printf "Set outgroup as $outgroup\n";
return $outgroup;
}

sub checktranslate {
my $aaaln=$_[0];
my $ntstr=$_[1];
my $ter=$_[2];
my $seqid=$_[3];
my $outstr=$_[4];
my $pm=$_[5];
my $aalen=length($aaaln);
my $ntlen=length($ntstr);
my ($ntseq,$i);
for(my $frame=1;$frame<=3;$frame++) {
my $j=$frame-1;
for($i=0;$i<$aalen;$i++) {
        my $base=substr($aaaln,$i,1);
        if($base eq '-') {}
        elsif($j>=$ntlen) {$i+=1;$pm->finish(0,[$outstr,"\nError: no codon can be extracted in $seqid: $i-$base!"]);}
        else {
                my $codon=substr($ntstr,$j,3);
                my $transbase=(Bio::Tools::CodonTable->new(-id=>1))->translate($codon);
                if($transbase eq '*') {
                        if($base eq $ter) {$ntseq.=$codon;}
                        else {$outstr.="\nWarning: there is an unexpected termination codon in $seqid: $i-$base-$transbase($codon)\n";$i-=1;}
                        if($j+3<$ntlen) {$outstr.="\nWarning: there is a middle termination codon in $seqid: $i-$base-$transbase($codon)\n";}
                }
                elsif($base eq $transbase) {$ntseq.=$codon;}
		else {
                        $outstr.="\nWarning: the codon does not match the amino acid in reading frame $frame in $seqid: $i-$base-$transbase($codon), will try next position!!!\n";
                        $ntseq="";
                        last;
                }
                $j+=3;
        }
}
unless($ntseq) {next;}
if($j+3==$ntlen&&(Bio::Tools::CodonTable->new(-id=>1))->is_ter_codon(substr($ntstr,$j,3))) {
        my $codon=substr($ntstr,$j,3);
        $i+=1;
        $outstr.="\nWarning: there is an unexpected termination codon in $seqid: $i-end-*($codon)\n";
}
elsif($j!=$ntlen) {
        $outstr.="\nWarning: nt length does not match the aa length in $seqid!!!\n";
}
last;
}
if(length($ntseq)==0&&$aalen>0&&$ntlen>0) {$pm->finish(0,[$outstr,"\nError: the codon does not match the amino acid in all 3 reading frames in $seqid!\n"]);}
return ($ntseq,$outstr);
}

sub checknum {
my (@OGs,@OGs0);
if($_[2]) {
	open(OGLIST,"<$_[2]") or die "\nError: fail to open $_[2]!\n";
	while(<OGLIST>) {
        	chomp;
        	push(@OGs0,$_);
	}
	close(OGLIST);
}
my $n=0;
opendir(DIR,$_[0]) or die "\nError: fail to open the directory '$_[0]'!\n";
my @files=readdir(DIR);
closedir(DIR);
foreach my $file (@files) {
	unless($file=~s/\.fa$//) {next;}
	if($_[2]) {unless($file~~@OGs0) {next;}}
        if(-e "$_[1]/$file.ok") {$n+=1;next;}
	push(@OGs,$file);
}
if($n>0) {printf "Already finished OGs: $n\n";}
@OGs=sort @OGs;
return (@OGs,$n);
}

sub runcmd {
my $cmd=$_[0];
unless($cmd=~/>/||$cmd=~/&&/) {$cmd.=' 2>&1';}
my $pm=$_[2];
my $outstr=$_[3];
open(LOG,">>$logdir/$_[1].log") or pmdie($pm,$outstr,"\nError: fail to open '$logdir/$_[1].log'!\n");
if($pm) {$outstr.="$cmd\n";}
else {printf "$cmd\n";}
print LOG "$cmd\n";
my ($iferr,$ifwarn,$templog);
$templog=`$cmd`;
$iferr=$?;
if($pm) {$outstr.=$templog;}
else {printf $templog;}
print LOG $templog;
close(LOG);
if($templog=~/error/i || $templog=~/fault/i || $templog=~/warn/i || $templog=~/sh: line/) {$ifwarn=1;}
if($iferr) {pmdie($pm,$outstr,"\nError in '$_[0]', please check $logdir/$_[1].log!\n");}
if($ifwarn) {
	if($pm) {$outstr.="\nWarning: there may be some errors or warnings in '$_[0]', please check $logdir/$_[1].log!\n";}
	else {printf "\nWarning: there may be some errors or warnings in '$_[0]', please check $logdir/$_[1].log!\n";}
}
if($pm) {return $outstr;}
else {return $templog;}
}

sub pmdie {
my $pm=$_[0];
if($pm) {$pm->finish(0,[$_[1],$_[2]]);}
else {die "$_[2]";}
}
